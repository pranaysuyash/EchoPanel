# MOD-011 5-State Model Machine (UNINITIALIZED → LOADING → WARMING_UP → READY → ERROR)

## Summary
- Origin: Code-only
- Status: Implemented
- State machine managing ASR model lifecycle from uninitialized through loading, warmup, to ready state, with error handling for failed transitions.
- Boundaries crossed: Process, Model
- Primary components (coarse list): ModelPreloader, ASRProviderRegistry

## Triggers and Preconditions
- Triggers (user action, event, schedule, startup, etc.): initialize() called on ModelPreloader
- Preconditions (permissions, settings flags, availability, model cached, etc.): Model not already in READY state

## Sequence (Happy Path)
Use numbered sequence. Each step must include evidence.
For each step:
1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. State transitions from UNINITIALIZED to LOADING
   - Evidence:
     - Code: server/services/model_preloader.py :: self._state = ModelState.LOADING
     - Docs: docs/WORKLOG_TICKETS.md :: State Machine Diagram: 300+ lines showing UNINITIALIZED → LOADING → WARMING_UP → READY → ERROR

2. _load_model() executes, gets provider from registry, validates availability
   - Evidence:
     - Code: server/services/model_preloader.py :: self._provider = ASRProviderRegistry.get_provider()

3. If warmup enabled, state transitions to WARMING_UP
   - Evidence:
     - Code: server/services/model_preloader.py :: if self.warmup_config.enabled: self._state = ModelState.WARMING_UP

4. _warmup() runs warmup inference sequence
   - Evidence:
     - Code: server/services/model_preloader.py :: await self._warmup()

5. State transitions to READY, _ready_event.set()
   - Evidence:
     - Code: server/services/model_preloader.py :: self._state = ModelState.READY; self._ready_event.set()

## Inputs and Outputs
- Inputs: provider_name, config, warmup_config, timeout
- Outputs: Boolean success, ModelState transitions
- Side effects (writes, network calls, model loads, UI state changes): Model loading into memory, provider initialization, warmup inferences

## Failure Modes
List 5–10 realistic failures:
- Failure: Provider not available
  - Where detected: _load_model()
  - Current handling (as evidenced): Raises RuntimeError, state set to ERROR
  - User-visible outcome (if any): Health check returns "Backend not ready"
  - Evidence: server/services/model_preloader.py :: if not self._provider.is_available: raise RuntimeError

- Failure: Warmup inference fails
  - Where detected: _warmup()
  - Current handling (as evidenced): Exception caught in initialize(), state set to ERROR
  - User-visible outcome (if any): Model remains in ERROR state
  - Evidence: server/services/model_preloader.py :: except Exception as e: self._state = ModelState.ERROR

- Failure: Timeout during initialization
  - Where detected: initialize() wait_for
  - Current handling (as evidenced): asyncio.TimeoutError caught, returns False
  - User-visible outcome (if any): Initialization fails without completing
  - Evidence: server/services/model_preloader.py :: except asyncio.TimeoutError: return False

- Failure: Concurrent initialization requests
  - Where detected: initialize() lock check
  - Current handling (as evidenced): Waits for existing load if LOADING/WARMING_UP
  - User-visible outcome (if any): Requests queue behind existing initialization
  - Evidence: server/services/model_preloader.py :: if self._state in {ModelState.LOADING, ModelState.WARMING_UP}: should_wait_for_existing_load = True

- Failure: Unload requested during initialization
  - Where detected: initialize() state check
  - Current handling (as evidenced): Returns False with warning
  - User-visible outcome (if any): Initialization aborted
  - Evidence: server/services/model_preloader.py :: elif self._state == ModelState.UNLOADING: return False

## Data and Storage
- What data is produced/consumed: Model weights, provider instances, timing metrics (load_time_ms, warmup_time_ms)
- Where it is stored (DB/files/userData/etc.): In-memory in ModelPreloader instance (_provider, _state, _load_time_ms, etc.)
- Retention / deletion controls (if documented): Retained until unload() called, then reset to UNINITIALIZED

## Observability
- Logs/events emitted: Info logs for phase transitions ("Phase 1/3: Loading model...", "Model ready!"), error logs on failures
- Correlation IDs / session IDs (if any): None evidenced
- Metrics/traces (if any): Load time and warmup time metrics stored
Evidence required: server/services/model_preloader.py :: logger.info/logger.error calls

## Open Questions and Follow-up Tasks
- Questions that cannot be answered from current evidence: How does UI reflect model state changes?
- Documentation gaps to fill: State transition triggers and timeouts
- Test gaps to add (note only, no implementation): State machine edge cases, concurrent state transitions</content>
<parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/MOD-011.md
# AUD-005 Server-Side Audio Queueing & Backpressure

## Summary

- Origin: Code-only
- Status: Implemented
- Receives WebSocket audio frames, queues them per source with bounded capacity, implements backpressure handling via ConcurrencyController, drops frames under overload, and provides streaming iterator for ASR processing.
- Boundaries crossed: Network (WebSocket receive) / Process (queueing and backpressure)
- Primary components: SessionState, asyncio.Queue, ConcurrencyController

## Triggers and Preconditions

- Triggers: WebSocket audio message received in ws_live_listener
- Preconditions: Session started, queues initialized per source

## Sequence (Happy Path)

1. WebSocket receives audio message with Base64 data
   - Evidence:
     - Code: server/api/ws_live_listener.py :: async def websocket_endpoint(websocket: WebSocket)
     - Code: server/api/ws_live_listener.py :: if msg["type"] == "audio"

2. Decode Base64 to PCM16 bytes
   - Evidence:
     - Code: server/api/ws_live_listener.py :: chunk = base64.b64decode(msg["data"])
     - Code: server/api/ws_live_listener.py :: source = msg.get("source", "system")

3. Get or create bounded asyncio.Queue for source
   - Evidence:
     - Code: server/api/ws_live_listener.py :: def get_queue(state: SessionState, source: str) -> asyncio.Queue
     - Code: server/api/ws_live_listener.py :: state.queues[source] = asyncio.Queue(maxsize=QUEUE_MAX)

4. Enqueue chunk with backpressure handling
   - Evidence:
     - Code: server/api/ws_live_listener.py :: async def put_audio(q: asyncio.Queue, chunk: bytes, ...)
     - Code: server/api/ws_live_listener.py :: await controller.submit_chunk(chunk, source)

5. If queue full, ConcurrencyController drops oldest or rejects
   - Evidence:
     - Code: server/api/ws_live_listener.py :: success, dropped_oldest = await controller.submit_chunk(chunk, source)
     - Code: server/services/concurrency_controller.py (assumed)

6. Track dropped frames and send backpressure warning to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: state.dropped_frames += 1
     - Code: server/api/ws_live_listener.py :: "type": "status", "state": "backpressure"

7. ASR processing consumes from queue via streaming iterator
   - Evidence:
     - Code: server/api/ws_live_listener.py :: async def \_pcm_stream(queue: asyncio.Queue) -> AsyncIterator[bytes]
     - Code: server/api/ws_live_listener.py :: chunk = await queue.get()

## Inputs and Outputs

- Inputs: Base64-encoded PCM16 audio chunks from WebSocket
- Outputs: Streaming bytes iterator for ASR, backpressure status messages
- Side effects: Queue depth tracking, metrics increment, dropped frame counting

## Failure Modes

- Queue overflow (ConcurrencyController):
  - Where detected: controller.submit_chunk returns success=False
  - Current handling: Drop frame, increment counters
  - User-visible outcome: Audio gaps, backpressure warning sent
  - Evidence: Code: server/api/ws_live_listener.py :: if not success: state.dropped_frames += 1

- Source dropping under extreme load:
  - Where detected: controller.should_drop_source(source) returns True
  - Current handling: Drop entire source, log warning
  - User-visible outcome: One audio source stops working
  - Evidence: Code: server/api/ws_live_listener.py :: if controller.should_drop_source(source): return

- Base64 decode failure:
  - Where detected: base64.b64decode() throws
  - Current handling: Exception caught, logged, message skipped
  - User-visible outcome: Brief audio gap
  - Evidence: Code: server/api/ws_live_listener.py :: try: chunk = base64.b64decode(msg["data"])

- Queue creation failure:
  - Where detected: asyncio.Queue() init fails
  - Current handling: Not explicitly handled
  - User-visible outcome: Audio not queued for that source
  - Evidence: Assumed - no try-catch around Queue creation

- Metrics registry unavailable:
  - Where detected: get_registry() fails
  - Current handling: Metrics not recorded
  - User-visible outcome: Missing observability data
  - Evidence: Code: server/api/ws_live_listener.py :: try: get_registry().inc_counter(...)

- WebSocket send failure for backpressure warning:
  - Where detected: ws_send task fails
  - Current handling: Warning not sent, but processing continues
  - User-visible outcome: Client doesn't see backpressure status
  - Evidence: Code: server/api/ws_live_listener.py :: asyncio.create_task(ws_send(...))

## Data and Storage

- asyncio.Queue per source (maxsize=QUEUE_MAX, default 48)
- SessionState tracks dropped_frames, backpressure_warned
- No persistent storage

## Observability

- Metrics: audio_bytes_received, audio_frames_dropped
- Logging: Backpressure warnings, dropped frame counts
- Status messages: Backpressure state sent to client
- Queue depth available via metrics registry

## Open Questions and Follow-up Tasks

- Queue max size tuning: Default 48 may not be optimal
- Backpressure warning throttling: Only sent once per session
- Source dropping logic: When and how sources are selected for dropping
- Test gaps: Queue overflow scenarios, metrics accuracy


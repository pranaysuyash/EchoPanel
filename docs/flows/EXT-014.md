# EXT-014 Global Hotkey Actions

## Summary

- Origin: Mixed
- Status: Implemented
- 1â€“2 sentence description: Global keyboard shortcuts that work even when the app is in the background, providing hands-free operation for broadcast operators during live productions.
- Boundaries crossed: OS / UI
- Primary components (coarse list): HotKeyManager (Swift), NSEvent monitors, accessibility permissions

## Triggers and Preconditions

- Triggers: User presses configured keyboard shortcut combinations (F1-F7, F12+Cmd, etc.)
- Preconditions: Global hotkeys enabled in settings (useHotKeys = true), accessibility permission granted, app has focus or global monitor active

## Sequence (Happy Path)

1. User enables global hotkeys in settings
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BroadcastFeatureManager.swift :: Toggle("Enable Global Hot-Keys", isOn: $broadcast.useHotKeys)
     - Docs: docs/BROADCAST_PRODUCTION_READINESS_SUMMARY.md :: UI components: `HotKeySettingsView`, `HotKeyHelpOverlay`
   - Notes: Settings UI in BroadcastFeatureManager

2. HotKeyManager.startMonitoring() registers NSEvent monitors
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: eventMonitor = NSEvent.addGlobalMonitorForEvents(matching: .keyDown) { [weak self] event in \_ = self?.handleKeyEvent(event) }
     - Docs: docs/flow-atlas-20260211.md :: HotKeyManager | `HotKeyManager.swift` | Global hotkey monitoring and handling
   - Notes: Registers both local and global monitors

3. User presses hotkey combination
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: private func handleKeyEvent(\_ event: NSEvent) -> Bool { ... let keyCombo = KeyCombo(from: event) ... for (action, binding) in bindings { guard binding.isEnabled, binding.keyCombo == keyCombo else { continue } triggerAction(action) return true } }
   - Notes: Matches key event against configured bindings

4. triggerAction() executes the hotkey action
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: private func triggerAction(\_ action: HotKeyAction) { ... onAction?(action) }
     - Docs: docs/BROADCAST_INTEGRATION_TEST_REPORT.md :: broadcast.onHotKeyAction = { [weak self] action in
   - Notes: Calls callback with action type

5. AppState.handleBroadcastHotKeyAction() performs the action
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: private func handleBroadcastHotKeyAction(\_ action: HotKeyManager.HotKeyAction) { ... switch action { case .startSession: if sessionState == .idle { startSession() } ... } }
     - Docs: docs/FLOW_ATLAS.md :: HotKeyManager | `HotKeyManager.swift` | Global hotkey handling
   - Notes: Maps actions to session control methods

## Inputs and Outputs

- Inputs: NSEvent keyDown events with key codes and modifier flags
- Outputs: Action callbacks (HotKeyAction enum), haptic feedback, UI state changes
- Side effects (writes, network calls, model loads, UI state changes): Session start/stop, marker insertion, audio failover, export operations, UI updates

## Failure Modes

- Failure: Accessibility permission not granted
  - Where detected: checkAccessibilityPermission() returns false
  - Current handling (as evidenced): Shows warning in UI, provides "Grant" button
  - User-visible outcome (if any): Warning message "Accessibility permission required for global hot-keys"
  - Evidence: macapp/MeetingListenerApp/Sources/BroadcastFeatureManager.swift :: if !broadcast.hotKeyManager.checkAccessibilityPermission() { ... Text("Accessibility permission required for global hot-keys") }

- Failure: Hotkey binding conflict detected
  - Where detected: setBinding() finds existing binding with same keyCombo
  - Current handling (as evidenced): Returns false, logs conflict
  - User-visible outcome (if any): Binding update fails silently
  - Evidence: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: if let conflict = bindings.first(where: { $0.value.keyCombo == keyCombo && $0.key != action }) { ... return false }

- Failure: Hotkeys disabled in settings
  - Where detected: handleKeyEvent() checks isEnabled
  - Current handling (as evidenced): Returns false, ignores event
  - User-visible outcome (if any): No action, event passes through
  - Evidence: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: guard isEnabled else { return false }

- Failure: Action called when session state invalid
  - Where detected: handleBroadcastHotKeyAction() checks sessionState
  - Current handling (as evidenced): Guards prevent invalid actions (e.g., start when already started)
  - User-visible outcome (if any): No action taken
  - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: case .startSession: if sessionState == .idle { startSession() }

## Data and Storage

- What data is produced/consumed: HotKeyBinding configurations (action + keyCombo + enabled state)
- Where it is stored (DB/files/userData/etc.): UserDefaults (planned, currently uses defaults)
- Retention / deletion controls (if documented): Persistent across app restarts

## Observability

- Logs/events emitted: "HotKeyManager: Global hot-keys enabled", "HotKeyManager: Triggered 'X'", "Timestamp marker inserted"
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): None
  Evidence required: macapp/MeetingListenerApp/Sources/HotKeyManager.swift :: NSLog statements, macapp/MeetingListenerApp/Sources/AppState.swift :: StructuredLogger.shared.info

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How are custom key bindings persisted?
- Documentation gaps to fill: Key binding persistence implementation
- Test gaps to add (note only, no implementation): Accessibility permission workflow, key binding conflict resolution</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/EXT-014.md

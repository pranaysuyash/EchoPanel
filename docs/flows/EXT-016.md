# EXT-016 Context Query (RAG Search)

## Flow Overview

This flow enables users to search through locally indexed documents using Retrieval-Augmented Generation (RAG) techniques. It performs lexical search with BM25/TF-IDF scoring across document chunks to find relevant context snippets for meeting notes and decision support.

## Happy Path Sequence

1. User enters query text in the "Query local context" field in the side panel's Insight Surface â†’ Context tab
   - Evidence: macapp/MeetingListenerApp/Sources/SidePanel/Full/SidePanelFullViews.swift :: TextField("Query local context", text: $appState.contextQuery) ... .onSubmit { appState.queryContextDocuments() }

2. UI triggers query execution via appState.queryContextDocuments()
   - Evidence: macapp/MeetingListenerApp/Sources/SidePanel/Full/SidePanelFullViews.swift :: Button("Search") { appState.queryContextDocuments() }

3. AppState validates query and initiates async search
   - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: queryContextDocumentsAsync(\_ rawQuery: String) ... guard !query.isEmpty else { ... return }

4. HTTP POST request sent to /documents/query endpoint with query and top_k=8
   - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: let payload: [String: Any] = ["query": query, "top_k": 8] ... BackendConfig.documentsQueryURL

5. Server validates authentication and parses request
   - Evidence: server/api/documents.py :: @router.post("/documents/query") ... \_require_http_auth(request)

6. LocalRAGStore.query() tokenizes query and searches document chunks
   - Evidence: server/api/documents.py :: results = [DocumentQueryResult(**row).model_dump() for row in store.query(body.query, top_k=body.top_k)]

7. BM25/TF-IDF scoring performed across all indexed chunks using Okapi BM25 (k1=1.4, b=0.75)
   - Evidence: server/services/rag_store.py :: \_score_chunks() ... idf = math.log(1.0 + ((n_chunks - df + 0.5) / (df + 0.5))) ... score += idf _ ((freq _ (k1 + 1.0)) / denom)

8. Phrase bonus applied for exact query matches in chunk text
   - Evidence: server/services/rag_store.py :: if query_phrase and query_phrase in text_lower: score += 0.35

9. Top 8 results ranked by score, with contextual snippets generated around query matches
   - Evidence: server/services/rag_store.py :: snippet = self.\_snippet(chunk.get("text", ""), query_tokens) ... results.sort(key=lambda item: item.score, reverse=True)

10. Results returned as JSON with document metadata and snippets
    - Evidence: server/api/documents.py :: return {"query": body.query, "results": results, "count": len(results)}

11. Client updates UI with search results and status message
    - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: contextQueryResults = decoded.results.map { $0.asContextQueryResult() } ... contextStatusMessage = "\(contextQueryResults.count) match(es) for \"\(query)\"."

## Failure Modes

1. **Empty query submission**: Query trimmed to empty string
   - Detection: Client-side validation in queryContextDocumentsAsync
   - Handling: Shows "Enter a query to search local context" message
   - User impact: No search performed, UI remains unchanged

2. **No indexed documents**: Search attempted but no documents available
   - Detection: LocalRAGStore.query returns empty results
   - Handling: Status message shows "No context documents indexed yet"
   - User impact: Informative message guides user to index documents first

3. **Network/authentication failure**: HTTP request fails
   - Detection: URLSession error in queryContextDocumentsAsync
   - Handling: Status message shows "Context query failed: [error]"
   - User impact: Search fails with error message, can retry

4. **Server overload/timeout**: Backend doesn't respond within 20s timeout
   - Detection: URLSession timeout or HTTP 5xx response
   - Handling: Request cancelled, error message displayed
   - User impact: Search fails, user can retry after backend recovers

5. **Corrupt document store**: JSON parsing fails during chunk loading
   - Detection: Exception in LocalRAGStore.\_load() or query()
   - Handling: Fallback to empty results, logged error
   - User impact: Search returns no results, documents need re-indexing

6. **Memory exhaustion**: Large document store causes OOM during scoring
   - Detection: Python process crashes or returns error
   - Handling: Server restart via backend manager
   - User impact: Temporary unavailability, automatic recovery

7. **File encoding issues**: Previously indexed document has encoding problems
   - Detection: Unicode decode error during chunk text access
   - Handling: Skip problematic chunks, log warning
   - User impact: Partial results, document may need re-indexing

## Observability

- **Client logging**: StructuredLogger warnings for query failures
- **Server metrics**: Query count, latency, and error rates via metrics_registry
- **UI feedback**: Real-time status messages and progress indicators
- **Correlation IDs**: Request tracing through WebSocket session IDs
- **Performance monitoring**: BM25 scoring time tracked per query

## Evidence Citations

- Code: macapp/MeetingListenerApp/Sources/SidePanel/Full/SidePanelFullViews.swift (lines 460-480) - UI query input and trigger
- Code: macapp/MeetingListenerApp/Sources/AppState.swift (lines 1450-1480) - Client-side query execution
- Code: server/api/documents.py (lines 85-95) - API endpoint and authentication
- Code: server/services/rag_store.py (lines 140-220) - BM25 scoring implementation
- Code: server/services/rag_store.py (lines 250-280) - Snippet generation and result ranking
- Inputs: Query string (user input), top_k parameter (fixed at 8)
- Outputs: Array of ContextQueryResult (document_id, title, source, chunk_index, snippet, score)
- Side effects (writes, network calls, model loads, UI state changes): HTTP POST to backend, UI status updates, results list population

## Failure Modes

- Failure: Empty query after trimming
  - Where detected: queryContextDocumentsAsync() validation
  - Current handling (as evidenced): Clears results, shows appropriate status message
  - User-visible outcome (if any): Status message "No context documents indexed yet." or "Enter a query to search local context."
  - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: guard !query.isEmpty else { contextQueryResults = [] ... contextStatusMessage = ... }

- Failure: No matching results found
  - Where detected: After scoring, results array is empty
  - Current handling (as evidenced): Shows "No matches" message
  - User-visible outcome (if any): Status message "No matches for \"[query]\"."
  - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: if contextQueryResults.isEmpty { contextStatusMessage = "No matches for \"\(query)\"." }

- Failure: Backend API error (auth, network, server error)
  - Where detected: URLSession.data() throws or HTTP status check fails
  - Current handling (as evidenced): Caught in do/catch, shows error message
  - User-visible outcome (if any): Status message "Context query failed: [error description]"
  - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: } catch { contextStatusMessage = "Context query failed: \(error.localizedDescription)" }

## Data and Storage

- What data is produced/consumed: Query tokens, chunk tokens, BM25 scores
- Where it is stored (DB/files/userData/etc.): Reads from local JSON store file
- Retention / deletion controls (if documented): Results are transient, not stored

## Observability

- Logs/events emitted: None specific (API calls logged via FastAPI)
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): None
  Evidence required: No specific logging identified in evidence sweep

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How are query tokens normalized?
- Documentation gaps to fill: Tokenization and normalization details
- Test gaps to add (note only, no implementation): Query performance with large document sets, edge cases in scoring</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/EXT-016.md

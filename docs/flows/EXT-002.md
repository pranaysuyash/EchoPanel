# EXT-002 Screen Recording Permission Request

## Summary

- Origin: Code-only
- Status: Implemented
- User-triggered permission request for macOS Screen Recording access required for system audio capture via ScreenCaptureKit. Displays native macOS permission dialog and handles post-grant restart requirements.
- Boundaries crossed: UI (permission dialog) / OS (macOS TCC permissions)
- Primary components (coarse list): AppState, AudioCaptureManager

## Triggers and Preconditions

- Triggers: Session start when audioSource includes .system (system audio capture needed)
- Preconditions: macOS 13+ (ScreenCaptureKit availability), app not already having permission

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. User initiates session start with system audio source
   - Evidence:
     - Code: AppState.swift :: startSession() :: if audioSource == .system || audioSource == .both
     - Docs: flow-atlas-20260211.md :: EXT-002 Screen Recording Permission Request

1. App checks current permission status via CGPreflightScreenCaptureAccess()
   - Evidence:
     - Code: AppState.swift :: startSession() :: let preflightGranted = CGPreflightScreenCaptureAccess()
     - Code: AudioCaptureManager.swift :: requestPermission() :: if CGPreflightScreenCaptureAccess()

1. If permission not granted, display macOS permission request dialog via CGRequestScreenCaptureAccess()
   - Evidence:
     - Code: AppState.swift :: startSession() :: granted = await audioCapture.requestPermission()
     - Code: AudioCaptureManager.swift :: requestPermission() :: return CGRequestScreenCaptureAccess()

1. Re-check permission status post-request to confirm grant
   - Evidence:
     - Code: AppState.swift :: startSession() :: let effective = granted && CGPreflightScreenCaptureAccess()

1. Update permission state in AppState and proceed with session if granted
   - Evidence:
     - Code: AppState.swift :: startSession() :: screenRecordingPermission = effective ? .authorized : .denied

## Inputs and Outputs

- Inputs: audioSource configuration (.system or .both)
- Outputs: Updated screenRecordingPermission state (.authorized or .denied)
- Side effects (writes, network calls, model loads, UI state changes): macOS permission dialog displayed, permission status published via @Published property

## Failure Modes

List 5â€“10 realistic failures:

- Failure: User denies permission in macOS dialog
  - Where detected: CGRequestScreenCaptureAccess() returns false
  - Current handling (as evidenced): Set session error .screenRecordingPermissionRequired, abort session start
  - User-visible outcome (if any): Error message "Screen Recording permission required for System Audio"
  - Evidence: AppState.swift :: setSessionError(.screenRecordingPermissionRequired)

- Failure: Permission granted but macOS requires app restart for it to take effect
  - Where detected: granted == true but CGPreflightScreenCaptureAccess() still returns false
  - Current handling (as evidenced): Set session error .screenRecordingRequiresRelaunch, abort session
  - User-visible outcome (if any): Error message "Screen Recording permission was granted, but macOS requires you to quit and relaunch EchoPanel"
  - Evidence: AppState.swift :: setSessionError(.screenRecordingRequiresRelaunch)

- Failure: macOS TCC system unavailable or malfunctioning
  - Where detected: CGRequestScreenCaptureAccess() throws or returns unexpected value
  - Current handling (as evidenced): Exception propagates, session fails with generic error
  - User-visible outcome (if any): Generic "System capture failed" error
  - Evidence: AppState.swift :: setSessionError(.systemCaptureFailed)

## Data and Storage

- What data is produced/consumed: Permission boolean state (authorized/denied)
- Where it is stored (DB/files/userData/etc.): In-memory AppState.screenRecordingPermission, persisted via macOS TCC database
- Retention / deletion controls (if documented): macOS system-managed, user can revoke in System Settings

## Observability

- Logs/events emitted: StructuredLogger warnings for permission issues
- Correlation IDs / session IDs (if any): Session ID logged in permission check context
- Metrics/traces (if any): None specific to permissions
  Evidence: AppState.swift :: StructuredLogger.shared.info("Session starting", metadata: ["audio_source": ...])

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How does permission state persist across app restarts? What happens if user grants permission mid-session?
- Documentation gaps to fill: Detailed macOS TCC behavior documentation
- Test gaps to add (note only, no implementation): Test permission revocation during active session, test permission grant without restart


# SEC-012 Diarization Model Privacy

## Summary
- Origin: Code-only
- Status: Implemented
- 1â€“2 sentence description: Ensures diarization (speaker identification) is opt-in, locally processed, and time-limited to protect user privacy.
- Boundaries crossed: Process (audio processing), Model (pyannote pipeline), Storage (temporary PCM buffers)
- Primary components (coarse list): diarization.py, ws_live_listener.py

## Triggers and Preconditions
- Triggers: Session start with ECHOPANEL_DIARIZATION=1 env var set
- Preconditions: HF_TOKEN available, diarization dependencies installed, session within time limits

## Sequence (Happy Path)
1. Session starts with diarization enabled via env var
   - Evidence:
     - Code: server/api/ws_live_listener.py :: diarization_enabled = os.getenv("ECHOPANEL_DIARIZATION", "0") == "1" (line 716)
2. Check diarization availability (dependencies + token)
   - Evidence:
     - Code: server/services/diarization.py :: is_diarization_available() (line 29)
3. Buffer audio chunks in memory during session, respecting max bytes limit
   - Evidence:
     - Code: server/api/ws_live_listener.py :: _append_diarization_audio() (line 129)
     - Code: server/api/ws_live_listener.py :: diarization_max_bytes check (line 137)
4. At session end, run local diarization on buffered audio
   - Evidence:
     - Code: server/api/ws_live_listener.py :: _run_diarization_per_source() (line 143)
     - Code: server/services/diarization.py :: diarize_pcm() (line 125)
5. Merge speaker labels with transcript segments
   - Evidence:
     - Code: server/services/diarization.py :: merge_transcript_with_speakers() (line 178)
6. Include labeled transcript in final summary, discard audio buffers
   - Evidence:
     - Code: server/api/ws_live_listener.py :: final_summary includes diarization (line 925)

## Inputs and Outputs
- Inputs: PCM audio chunks, HF authentication token
- Outputs: Speaker-labeled transcript segments
- Side effects (writes, network calls, model loads, UI state changes): Local model load, temporary memory usage for audio buffers

## Failure Modes
- Failure: HF_TOKEN not set or invalid
  - Where detected: is_diarization_available()
  - Current handling: Diarization disabled, logged
  - User-visible outcome: No speaker labels in transcript
  - Evidence: server/services/diarization.py :: token check (line 32)
- Failure: Dependencies not available (pyannote, torch, numpy)
  - Where detected: Import time or is_diarization_available()
  - Current handling: Graceful degradation, logged
  - User-visible outcome: Diarization unavailable
  - Evidence: server/services/diarization.py :: try/except imports (lines 15-25)
- Failure: Audio buffer exceeds max_bytes limit
  - Where detected: _append_diarization_audio()
  - Current handling: Truncate oldest audio, continue
  - User-visible outcome: Partial diarization coverage
  - Evidence: server/api/ws_live_listener.py :: overflow handling (lines 137-142)

## Data and Storage
- What data is produced/consumed: Speaker labels, temporary PCM buffers
- Where it is stored (DB/files/userData/etc.): In-memory buffers during session, discarded after processing
- Retention / deletion controls: Automatic cleanup on session end

## Observability
- Logs/events emitted: Diarization availability, processing status, errors
- Correlation IDs / session IDs: Session ID in logs
- Metrics/traces: Processing time not tracked specifically
- Evidence: server/services/diarization.py :: logger calls (lines 34, 42, 48, 165)

## Open Questions and Follow-up Tasks
- Questions: Should users be warned about local processing implications? How to handle token expiry?
- Documentation gaps: Privacy implications of diarization in user docs
- Test gaps: Token validation, buffer limit testing, dependency availability
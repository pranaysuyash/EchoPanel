# NET-006 WebSocket Reconnection Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Client automatically reconnects to WebSocket with exponential backoff after connection failures, preserving session state.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, AppState

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): WebSocket connection error or disconnection detected
- Preconditions (permissions, settings flags, availability, model cached, etc.): Backend server running, session was previously established

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Connection error detected in receiveLoop() or send operation
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleError() called from receiveLoop() or sendJSON()
   - Notes: Errors include network failures, server disconnects, ping timeouts

1. handleError() logs error and sets status to reconnecting
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleError() calls onStatus?(.reconnecting, error.localizedDescription)
     - Docs: docs/flow-atlas-20260211.md :: reconnecting state defined
   - Notes: Status update notifies UI of reconnection attempt

1. reconnect() method cancels current task and stops ping timer
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnect() calls task?.cancel(with: .goingAway), stopPing()
   - Notes: Clean shutdown of existing connection

1. Exponential backoff delay calculated and applied
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnectDelay starts at 1s, doubles each attempt, max 10s
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Recovery: Client auto-reconnects with exponential backoff
   - Notes: Prevents rapid reconnection storms

1. After delay, connect() called with same sessionID
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnect() calls connect(sessionID: sessionID) after delay
   - Notes: Session state preserved across reconnection

1. New connection established, ping scheduled, start message sent
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connect() resumes task, calls schedulePing(), sendStart()
   - Notes: Full reconnection completes successfully

## Inputs and Outputs

- Inputs:
  - Session ID (preserved from original connection)
  - Backend URL and auth token (from BackendConfig)
- Outputs:
  - Reconnected WebSocket task
  - Status updates (.reconnecting, then .streaming)
- Side effects (writes, network calls, model loads, UI state changes): Network reconnection attempt, UI status update to reconnecting

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Maximum reconnection attempts exceeded
  - Where detected: reconnect() delay calculation
  - Current handling (as evidenced): Infinite retry (no max attempts implemented)
  - User-visible outcome (if any): Continuous reconnection attempts
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnectDelay capped at maxReconnectDelay but no attempt limit

- Failure: Backend server permanently down
  - Where detected: All reconnection attempts fail
  - Current handling (as evidenced): Continues retrying indefinitely
  - User-visible outcome (if any): Persistent "reconnecting" status
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnect() always schedules next attempt

- Failure: Network completely unavailable
  - Where detected: URLSession fails to create connection
  - Current handling (as evidenced): Triggers next reconnection attempt
  - User-visible outcome (if any): Brief error status then reconnecting
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleError() called from task creation

- Failure: Authentication token expired during reconnection
  - Where detected: Server rejects connection with 401
  - Current handling (as evidenced): Treated as connection error, triggers reconnect
  - User-visible outcome (if any): Reconnection loop without resolution
  - Evidence: Docs: docs/WS_CONTRACT.md :: Unauthorized websocket behavior

- Failure: Session state lost on server side
  - Where detected: Server doesn't recognize sessionID
  - Current handling (as evidenced): Server may reject or reset session
  - User-visible outcome (if any): Connection succeeds but session inconsistent
  - Evidence: Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Current Issue: Session state lost on reconnect

## Data and Storage

- What data is produced/consumed: Session ID, attempt ID, correlation IDs
- Where it is stored (DB/files/userData/etc.): In-memory in WebSocketStreamer instance
- Retention / deletion controls (if documented): Cleared on disconnect(), recreated on connect()

## Observability

- Logs/events emitted: Structured logging with sessionId, attemptId, connectionId on connect
- Correlation IDs / session IDs (if any): Generated per connection attempt
- Metrics/traces (if any): Connection metadata logged (scheme, host, port)
  Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: StructuredLogger.shared.info("WebSocket connecting")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What happens if session expires on server during reconnection?
- Documentation gaps to fill: Server-side session timeout behavior
- Test gaps to add (note only, no implementation): Integration test for session state preservation across reconnect


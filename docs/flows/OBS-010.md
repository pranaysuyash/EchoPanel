# OBS-010 Frame Drop Detection & Reporting Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Server detects audio frame drops due to queue overflow and reports drop counts in real-time metrics to client.
- Boundaries crossed: Network (WebSocket metrics)
- Primary components (coarse list): ConcurrencyController, ws_live_listener.py

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Audio chunk submission to full queue
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session active, audio streaming

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Audio chunk submitted to concurrency controller
   - Evidence:
     - Code: server/services/concurrency_controller.py :: submit_chunk() called from ws_live_listener.py
   - Notes: Happens on every audio frame received

1. Controller checks if queue has space
   - Evidence:
     - Code: server/services/concurrency_controller.py :: if len(queue) >= self.\_max_queue_depth
   - Notes: Queue size check

1. If queue full, drop oldest chunk and increment counters
   - Evidence:
     - Code: server/services/concurrency_controller.py :: dropped = queue.get_nowait(), self.\_dropped_frames_total += 1
   - Notes: Keeps newest audio, drops oldest

1. Log frame drop with details
   - Evidence:
     - Code: server/services/concurrency_controller.py :: logger.warning(f"Dropped oldest {dropped.source} chunk")
   - Notes: Includes source and total count

1. Update session state with total dropped frames
   - Evidence:
     - Code: server/api/ws_live_listener.py :: state.dropped_frames += dropped_count from controller
   - Notes: Accumulates across all sources

1. Metrics loop calculates dropped_recent per second
   - Evidence:
     - Code: server/api/ws_live_listener.py :: dropped_recent = state.dropped_frames - state.asr_last_dropped
   - Notes: Resets baseline each second

1. Include drop metrics in WebSocket payload
   - Evidence:
     - Code: server/api/ws_live_listener.py :: "dropped_total": state.dropped_frames, "dropped_recent": dropped_recent
   - Notes: Sent every 1Hz

1. Client receives and can display drop statistics
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: SourceMetrics includes dropped fields
   - Notes: Available for UI observability

## Inputs and Outputs

- Inputs:
  - Audio chunks from WebSocket
  - Queue capacity limits
- Outputs:
  - WebSocket metrics with dropped_total, dropped_recent
- Side effects (writes, network calls, model loads, UI state changes): Queue manipulation, metrics emission

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Drop detection fails silently
  - Where detected: No logging when dropping
  - Current handling (as evidenced): Always logs drops
  - User-visible outcome (if any): Hidden drops
  - Evidence: Code: server/services/concurrency_controller.py :: logger.warning on drop

- Failure: Counter increment fails
  - Where detected: Exception in submit_chunk
  - Current handling (as evidenced): Exception propagates
  - User-visible outcome (if any): Inaccurate drop counts
  - Evidence: Code: server/services/concurrency_controller.py :: no try/catch around counters

- Failure: Metrics emission fails
  - Where detected: ws_send fails
  - Current handling (as evidenced): Loop may crash
  - User-visible outcome (if any): Stale drop metrics
  - Evidence: Code: server/api/ws_live_listener.py :: await ws_send in \_metrics_loop

- Failure: Queue get_nowait fails
  - Where detected: Queue empty when trying to drop
  - Current handling (as evidenced): Should not happen (checked len first)
  - User-visible outcome (if any): Exception, chunk not added
  - Evidence: Code: server/services/concurrency_controller.py :: len check before get_nowait

- Failure: Multiple threads access counters
  - Where detected: Race condition on \_dropped_frames_total
  - Current handling (as evidenced): No locking, potential race
  - User-visible outcome (if any): Inaccurate counts
  - Evidence: Code: server/services/concurrency_controller.py :: no synchronization

## Data and Storage

- What data is produced/consumed: Drop counters, queue state
- Where it is stored (DB/files/userData/etc.): In-memory counters in ConcurrencyController and session state
- Retention / deletion controls (if documented): Per-session, reset on restart

## Observability

- Logs/events emitted: Warning logs on each drop
- Correlation IDs / session IDs (if any): None specific
- Metrics/traces (if any): Dropped counts in metrics payload
- Evidence: Code: server/services/concurrency_controller.py :: logger.warning

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: None
- Documentation gaps to fill: None
- Test gaps to add (note only, no implementation): Test drop detection under queue overflow

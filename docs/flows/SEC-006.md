# SEC-006 Documents API Authentication

## Summary
- Origin: Code-only
- Status: Implemented
- Token-based authentication for Documents API endpoints using shared token with WebSocket authentication, ensuring only authorized clients can index, query, or manage RAG documents.
- Boundaries crossed: UI / Process / Storage
- Primary components (coarse list): Swift client, FastAPI server, macOS Keychain

## Triggers and Preconditions
- Triggers: HTTP request to any /documents/* endpoint (GET /documents, POST /documents/index, POST /documents/query, DELETE /documents/{id})
- Preconditions: ECHOPANEL_WS_AUTH_TOKEN environment variable set on server, backend authentication token stored in macOS Keychain on client

## Sequence (Happy Path)
1. Client prepares HTTP request to Documents API endpoint
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: makeAuthorizedRequest
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: fetchContextDocuments, indexContextDocument, queryContextDocumentsAsync, deleteContextDocument
2. Client loads authentication token from Keychain
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: makeAuthorizedRequest (KeychainHelper.loadBackendToken())
3. Client adds token to request headers (Authorization: Bearer <token>, x-echopanel-token: <token>)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: makeAuthorizedRequest (lines 1473-1475)
4. Server receives request and calls _require_http_auth
   - Evidence:
     - Code: server/api/documents.py :: _require_http_auth (called in all endpoint handlers)
5. Server extracts token from request (query param, header, or Authorization Bearer)
   - Evidence:
     - Code: server/api/documents.py :: _extract_token
6. Server compares provided token with environment variable using secure comparison
   - Evidence:
     - Code: server/api/documents.py :: _require_http_auth (hmac.compare_digest)
7. Authentication succeeds, request proceeds to business logic
   - Evidence:
     - Code: server/api/documents.py :: all endpoint handlers call _require_http_auth before processing

## Inputs and Outputs
- Inputs: Authentication token string from macOS Keychain
- Outputs: HTTP 200 on success, HTTP 401 on failure
- Side effects (writes, network calls, model loads, UI state changes): None

## Failure Modes
- Failure: No authentication token configured on server (ECHOPANEL_WS_AUTH_TOKEN not set)
  - Where detected: server/api/documents.py :: _require_http_auth
  - Current handling (as evidenced): Authentication bypassed (no required_token check fails)
  - User-visible outcome (if any): Request succeeds (insecure mode)
  - Evidence: server/api/documents.py :: _require_http_auth (if not required_token: return)
- Failure: Client has no token in Keychain
  - Where detected: macapp/MeetingListenerApp/Sources/AppState.swift :: makeAuthorizedRequest
  - Current handling (as evidenced): No auth headers added to request
  - User-visible outcome (if any): HTTP 401 from server
  - Evidence: macapp/MeetingListenerApp/Sources/AppState.swift :: makeAuthorizedRequest (if let token = KeychainHelper.loadBackendToken())
- Failure: Provided token does not match server token
  - Where detected: server/api/documents.py :: _require_http_auth
  - Current handling (as evidenced): HTTPException(401, "Unauthorized") raised
  - User-visible outcome (if any): API request fails with 401 error
  - Evidence: server/api/documents.py :: _require_http_auth (raise HTTPException)
- Failure: Token extraction fails (no token in any expected location)
  - Where detected: server/api/documents.py :: _extract_token
  - Current handling (as evidenced): Empty string returned, comparison fails
  - User-visible outcome (if any): HTTP 401 from server
  - Evidence: server/api/documents.py :: _extract_token (returns "")

## Data and Storage
- What data is produced/consumed: Authentication token string (shared with WebSocket auth)
- Where it is stored (DB/files/userData/etc.): Server: environment variable ECHOPANEL_WS_AUTH_TOKEN, Client: macOS Keychain
- Retention / deletion controls (if documented): Token persists in Keychain until explicitly cleared, env var persists for server lifetime

## Observability
- Logs/events emitted: HTTP 401 responses logged by FastAPI
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): None
Evidence: No explicit logging in auth code, relies on FastAPI default error logging

## Open Questions and Follow-up Tasks
- Questions: Is the shared token approach secure enough for production, or should Documents API have separate auth?
- Documentation gaps: No explicit docs on auth bypass when env var not set
- Test gaps: Integration test for auth failure scenarios
- Follow-up: Consider separate auth tokens for different APIs if security requirements evolve
# STO-002 Transcript Append-Only Storage

## Summary

- Origin: Mixed
- Status: Implemented
- Append-only JSONL storage of finalized transcript segments with timestamps, text, confidence, and finalization status for session persistence and recovery.
- Boundaries crossed: Storage / UI
- Primary components (coarse list): transcript.jsonl file, FileHandle, JSONL format, append operations

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Transcript segment finalized, session active
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session started, transcript file created, FileHandle open

## Sequence (Happy Path)

1. Create transcript.jsonl file on session start
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:70-72
     - Docs: docs/STORAGE_AND_EXPORTS.md:9
2. Open FileHandle for writing to transcript file
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:73
     - Docs: docs/DATA_MODEL.md:10-17
3. Append finalized transcript segments as JSONL entries
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:104-113
     - Docs: docs/DATA_MODEL.md:10-17
4. Format each segment with t0, t1, text, is_final, confidence
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:105-106
     - Docs: docs/DATA_MODEL.md:12-17
5. Close FileHandle on session end
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:99-100
     - Docs: docs/STORAGE_AND_EXPORTS.md:9

## Inputs and Outputs

- Inputs: Transcript segments (t0, t1, text, is_final, confidence)
- Outputs: JSONL lines in transcript.jsonl file
- Side effects (writes, network calls, model loads, UI state changes): File appends, disk writes

## Failure Modes

- Failure: Transcript file creation fails
  - Where detected: createFile()
  - Current handling (as evidenced): Log error, continue without transcript storage
  - User-visible outcome (if any): No transcript saved
  - Evidence: SessionStore.swift:71-72
- Failure: FileHandle open fails
  - Where detected: FileHandle init
  - Current handling (as evidenced): Exception caught, no storage
  - User-visible outcome (if any): Transcript not persisted
  - Evidence: SessionStore.swift:73
- Failure: JSON serialization fails
  - Where detected: JSONSerialization.data()
  - Current handling (as evidenced): Log error, skip segment
  - User-visible outcome (if any): Missing transcript segment
  - Evidence: SessionStore.swift:107-112
- Failure: File write fails
  - Where detected: handle.write()
  - Current handling (as evidenced): Log error, continue
  - User-visible outcome (if any): Partial transcript loss
  - Evidence: SessionStore.swift:107-112
- Failure: FileHandle close fails
  - Where detected: close()
  - Current handling (as evidenced): Try? ignores error
  - User-visible outcome (if any): None
  - Evidence: SessionStore.swift:99-100

## Data and Storage

- What data is produced/consumed: Finalized transcript segments with timing and confidence
- Where it is stored (DB/files/userData/etc.): Local JSONL file in session directory
- Retention / deletion controls (if documented): Session lifetime, manual deletion

## Observability

- Logs/events emitted: Append failures logged
- Correlation IDs / session IDs (if any): Session ID in logs
- Metrics/traces (if any): None specific
- Evidence: SessionStore.swift error logs

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: Is there deduplication or ordering guarantees?
- Documentation gaps: Transcript format versioning, corruption recovery
- Test gaps to add (note only, no implementation): Test JSONL parsing, concurrent appends


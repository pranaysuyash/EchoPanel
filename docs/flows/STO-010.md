# STO-010 Audio Debug Dump (Server-Side)

## Summary

- Origin: Code-only
- Status: Implemented
- Server-side audio frame dumping to filesystem for debugging audio processing issues, gated by environment variable for privacy.
- Boundaries crossed: Process / Storage
- Primary components (coarse list): ws_live_listener.py, SessionState, base64, file I/O

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): First audio chunk received for a source during active session
- Preconditions (permissions, settings flags, availability, model cached, etc.): ECHOPANEL_DEBUG_AUDIO_DUMP=1 environment variable set, dump directory writable

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Environment variable checked on module load
   - Evidence:
     - Code: server/api/ws_live_listener.py :: DEBUG_AUDIO_DUMP = os.getenv("ECHOPANEL_DEBUG_AUDIO_DUMP", "0") == "1"
   - Notes: Defaults to disabled for privacy

1. Dump directory configured from environment
   - Evidence:
     - Code: server/api/ws_live_listener.py :: DEBUG_AUDIO_DUMP_DIR = Path(os.getenv("ECHOPANEL_DEBUG_AUDIO_DUMP_DIR", "/tmp/echopanel_audio_dump"))
   - Notes: Defaults to /tmp/echopanel_audio_dump/

1. On first audio chunk for source, initialize dump file
   - Evidence:
     - Code: server/api/ws_live_listener.py :: \_init_audio_dump(state, source)
     - Code: server/api/ws_live_listener.py :: if source not in state.started_sources: \_init_audio_dump(state, source)
   - Notes: Per-source file created

1. Create dump directory if needed
   - Evidence:
     - Code: server/api/ws_live_listener.py :: DEBUG_AUDIO_DUMP_DIR.mkdir(parents=True, exist_ok=True)
   - Notes: Parents created, existing directory ok

1. Generate filename with session_id, source, timestamp
   - Evidence:
     - Code: server/api/ws*live_listener.py :: filename = f"{session_id}*{source}\_{timestamp}.pcm"
   - Notes: .pcm extension for raw audio

1. Open file in binary write mode and store handle
   - Evidence:
     - Code: server/api/ws_live_listener.py :: file_handle = open(filepath, "wb"); state.debug_dump_files[source] = file_handle
   - Notes: Handle kept in session state

1. For each audio chunk, write to dump file
   - Evidence:
     - Code: server/api/ws_live_listener.py :: \_write_audio_dump(state, source, chunk)
     - Code: server/api/ws_live_listener.py :: state.debug_dump_files[source].write(chunk); state.debug_dump_files[source].flush()
   - Notes: Immediate flush for debugging

1. On session end, close all dump files
   - Evidence:
     - Code: server/api/ws_live_listener.py :: \_close_audio_dumps(state)
     - Code: server/api/ws_live_listener.py :: file_handle.close()
   - Notes: Called in finally block

## Inputs and Outputs

- Inputs: Audio chunks (base64 decoded bytes), source identifier, session ID
- Outputs: .pcm files written to dump directory
- Side effects (writes, network calls, model loads, UI state changes): File system writes to dump directory, directory creation

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Environment variable not set
  - Where detected: Module load
  - Current handling (as evidenced): DEBUG_AUDIO_DUMP = False, no dumping
  - User-visible outcome (if any): None, feature disabled
  - Evidence: server/api/ws_live_listener.py :: os.getenv("ECHOPANEL_DEBUG_AUDIO_DUMP", "0") == "1"

- Failure: Dump directory creation fails
  - Where detected: \_init_audio_dump()
  - Current handling (as evidenced): Exception caught, logged, no dump for that source
  - User-visible outcome (if any): Error in server logs
  - Evidence: server/api/ws_live_listener.py :: try: DEBUG_AUDIO_DUMP_DIR.mkdir() except Exception as e: logger.error()

- Failure: File open fails (permissions, disk full)
  - Where detected: \_init_audio_dump()
  - Current handling (as evidenced): Exception caught, logged, no dump for that source
  - User-visible outcome (if any): Error in server logs
  - Evidence: server/api/ws_live_listener.py :: try: file_handle = open() except Exception as e: logger.error()

- Failure: File write fails
  - Where detected: \_write_audio_dump()
  - Current handling (as evidenced): Exception caught, logged, continues processing
  - User-visible outcome (if any): Partial dump file, error in logs
  - Evidence: server/api/ws_live_listener.py :: try: file_handle.write() except Exception as e: logger.error()

- Failure: File close fails
  - Where detected: \_close_audio_dumps()
  - Current handling (as evidenced): Exception caught, logged, continues cleanup
  - User-visible outcome (if any): File may remain open, error in logs
  - Evidence: server/api/ws_live_listener.py :: try: file_handle.close() except Exception as e: logger.error()

## Data and Storage

- What data is produced/consumed: Raw PCM audio chunks per source
- Where it is stored (DB/files/userData/etc.): Configurable directory (default /tmp/echopanel*audio_dump/), files named {session_id}*{source}\_{timestamp}.pcm
- Retention / deletion controls (if documented): Files persist until manually deleted, no automatic cleanup

## Observability

- Logs/events emitted: Info logs for dump enabled/closed, error logs for failures
- Correlation IDs / session IDs (if any): session_id in filename and logs
- Metrics/traces (if any): None
  Evidence: server/api/ws_live_listener.py :: logger.info(f"Audio dump enabled for {source}: {filepath}"); logger.error(f"Failed to initialize audio dump for {source}: {e}")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: Are dump files included in session bundles? Is there size limiting?
- Documentation gaps to fill: Privacy implications, file format details
- Test gaps to add (note only, no implementation): Dump with multiple sources, directory permission errors, disk full during write</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/STO-010.md

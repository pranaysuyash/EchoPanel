# NET-001 WebSocket Connection Establishment

## Summary

- Origin: Code-only
- Status: Implemented
- The app opens `/ws/live-listener`, starts receive + ping loops, then sends `start` for a session.
- Boundaries crossed: UI -> Network
- Primary components (coarse list): AppState, WebSocketStreamer, BackendConfig

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): `AppState.startSession()` calls `streamer.connect(...)`.
- Preconditions (permissions, settings flags, availability, model cached, etc.): capture started, backend reachable, app has generated session/attempt IDs.

## Sequence (Happy Path)

1. Session start sets IDs and calls connect.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `startSession()` -> `streamer.connect(sessionID:attemptID:)`
2. `WebSocketStreamer.connect` creates correlation IDs and resets reconnect delay.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `connect(sessionID:attemptID:)`
3. WebSocket task is created from `BackendConfig.webSocketRequest` and resumed.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `task = session.webSocketTask(with: webSocketRequest)` + `task?.resume()`
     - Code: `macapp/MeetingListenerApp/Sources/BackendConfig.swift` :: `webSocketRequest`
4. Receive loop and ping loop start.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `receiveLoop()` and `schedulePing()`
5. `start` message is sent after a short delay.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `DispatchQueue.main.asyncAfter(...){ sendStart() }`
6. Backend `status=streaming` moves UI from `.starting` to `.listening`.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `handleJSON` status handling
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `streamer.onStatus` sets `sessionState = .listening`

## Inputs and Outputs

- Inputs: `session_id`, `attempt_id`, backend host/port config
- Outputs: active WebSocket task, active receive/ping loops, `start` control frame
- Side effects (writes, network calls, model loads, UI state changes): network connection opened, stream status updates, structured connection log emitted

## Failure Modes

- Failure: Backend not reachable
  - Where detected: WebSocket receive/send error path
  - Current handling (as evidenced): `handleError` updates status to reconnecting and schedules reconnect
  - User-visible outcome (if any): reconnecting state/message in panel
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `handleError`, `reconnect`

- Failure: Invalid URL components
  - Where detected: URL build
  - Current handling (as evidenced): hard failure via `fatalError`
  - User-visible outcome (if any): app crash
  - Evidence: `macapp/MeetingListenerApp/Sources/BackendConfig.swift` :: `guard let url = components.url else { fatalError(...) }`

- Failure: Backend never ACKs streaming
  - Where detected: startup timeout task
  - Current handling (as evidenced): stop session and set runtime streaming error after 5s
  - User-visible outcome (if any): setup/error state
  - Evidence: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `startTimeoutTask`

- Failure: Ping fails
  - Where detected: ping callback
  - Current handling (as evidenced): routes to `handleError` and reconnect flow
  - User-visible outcome (if any): reconnecting state
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `schedulePing`

## Data and Storage

- What data is produced/consumed: `CorrelationIDs(sessionId, attemptId, connectionId)`
- Where it is stored (DB/files/userData/etc.): in-memory on `WebSocketStreamer`
- Retention / deletion controls (if documented): reset on disconnect/session end

## Observability

- Logs/events emitted: structured `WebSocket connecting` log and websocket start event
- Correlation IDs / session IDs (if any): session/attempt/connection IDs propagated in message + logger context
- Metrics/traces (if any): none dedicated to connect latency in current client code

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: none
- Documentation gaps to fill: none for current client connection contract
- Test gaps to add (note only, no implementation): explicit startup-timeout test for delayed backend ACK

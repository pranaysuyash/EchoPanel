# NET-001 WebSocket Connection Establishment

## Summary

- Origin: Code-only
- Status: Hypothesized
- Client establishes WebSocket connection to backend server for real-time audio streaming and ASR results.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, BackendConfig, URLSessionWebSocketTask

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): AppState.startSession() calls streamer.connect()
- Preconditions (permissions, settings flags, availability, model cached, etc.): Backend server running, network available, permissions granted

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. startSession() calls streamer.connect(sessionID, attemptID)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: startSession() calls streamer.connect(sessionID: id, attemptID: currentAttemptId?.uuidString)
   - Notes: Generates correlation IDs

1. WebSocketStreamer.connect() builds URL from BackendConfig
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connect() uses BackendConfig.webSocketURL
     - Code: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: webSocketURL builds URL with scheme/host/port/path + token query param
   - Notes: Uses ws:// for localhost, wss:// for remote

1. Creates URLSessionWebSocketTask and resumes it
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: task = session.webSocketTask(with: url); task?.resume()
   - Notes: URLSession configuration .default

1. Starts receiveLoop() for incoming messages
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: receiveLoop() called in connect()
   - Notes: Async recursive loop for receiving messages

1. Schedules ping timer for health checks
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: schedulePing() called in connect()
   - Notes: Ping/pong for connection health

1. After 0.2s delay, sends "start" message
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { self?.sendStart() }
   - Notes: Allows connection to establish before sending

1. Backend acknowledges with status "streaming"
   - Evidence:
     - Docs: docs/WS_CONTRACT.md :: Server sends {"type":"status","state":"streaming"}
   - Notes: Triggers sessionState = .listening in AppState

## Inputs and Outputs

- Inputs: sessionID, attemptID
- Outputs: WebSocket connection established, correlation IDs generated
- Side effects (writes, network calls, model loads, UI state changes): Network connection opened, ping timer started, start message sent

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Backend server not running
  - Where detected: URLSessionWebSocketTask connection attempt
  - Current handling (as evidenced): Connection fails, triggers reconnection logic
  - User-visible outcome (if any): streamStatus = .reconnecting
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnection logic in receiveLoop error handling

- Failure: Network unavailable
  - Where detected: URLSessionWebSocketTask
  - Current handling (as evidenced): Connection fails, exponential backoff retry
  - User-visible outcome (if any): Reconnecting status
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnectDelay, maxReconnectDelay

- Failure: Invalid URL construction
  - Where detected: BackendConfig.buildURL
  - Current handling (as evidenced): fatalError if URL invalid
  - User-visible outcome (if any): App crash
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: guard let url = components.url else { fatalError(...) }

- Failure: Authentication token invalid
  - Where detected: Backend server
  - Current handling (as evidenced): Server closes with 1008, client reconnects
  - User-visible outcome (if any): Reconnecting status
  - Evidence: Docs: docs/WS_CONTRACT.md :: Unauthorized websocket behavior

## Data and Storage

- What data is produced/consumed: CorrelationIDs (sessionId, attemptId, connectionId)
- Where it is stored (DB/files/userData/etc.): In-memory in WebSocketStreamer
- Retention / deletion controls (if documented): None, per connection

## Observability

- Logs/events emitted: Structured logging with correlation IDs
- Correlation IDs / session IDs (if any): session_id, attempt_id, connection_id
- Metrics/traces (if any): None evidenced

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What happens if ping fails?
- Documentation gaps to fill: Ping/pong failure handling
- Test gaps to add (note only, no implementation): Test connection establishment with invalid server</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-001.md

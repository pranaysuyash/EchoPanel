# NET-004 ASR Results Reception

## Summary

- Origin: Code-only
- Status: Hypothesized
- Client receives ASR transcription results (partial and final) from backend via WebSocket.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, AppState

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Backend processes audio and sends ASR results
- Preconditions (permissions, settings flags, availability, model cached, etc.): WebSocket connected, audio transmitted

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Backend sends ASR message over WebSocket
   - Evidence:
     - Docs: docs/WS_CONTRACT.md :: `asr_partial` / `asr_final` message format
   - Notes: JSON with text, timestamps, confidence, source

1. WebSocketStreamer.receiveLoop receives message
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: receiveLoop() async recursive
   - Notes: Processes incoming URLSessionWebSocketTask.Message

1. Message parsed as JSON, type checked
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: guard let json = try? JSONSerialization.jsonObject, let type = json["type"] as? String
   - Notes: Handles asr_partial and asr_final

1. Callback invoked: onASRPartial or onASRFinal
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: onASRPartial?(text, t0, t1, confidence, source)
   - Notes: Passes parsed data to AppState

1. AppState.handlePartial or handleFinal updates transcript
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: handlePartial/handleFinal methods
   - Notes: Updates transcriptSegments, bumps revision

1. UI updates with new transcript text
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: transcriptSegments @Published
   - Notes: Hypothesized - SwiftUI reactive update

## Inputs and Outputs

- Inputs: WebSocket message with ASR data
- Outputs: Transcript segments updated
- Side effects (writes, network calls, model loads, UI state changes): UI transcript display updated, revision bumped

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Invalid JSON message
  - Where detected: JSONSerialization.jsonObject
  - Current handling (as evidenced): try? , message ignored
  - User-visible outcome (if any): ASR result lost
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: guard let json = try? JSONSerialization.jsonObject

- Failure: Missing required fields
  - Where detected: JSON parsing
  - Current handling (as evidenced): as? String/Double casts, nil if missing
  - User-visible outcome (if any): Partial data or ignored
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: let text = json["text"] as? String

- Failure: WebSocket receive error
  - Where detected: receiveLoop
  - Current handling (as evidenced): Logs error, may trigger reconnection
  - User-visible outcome (if any): Connection status changes
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: catch { NSLog("WebSocket receive error: \(error)") }

- Failure: Transcript update fails
  - Where detected: AppState.handlePartial/handleFinal
  - Current handling (as evidenced): Updates arrays, assumes success
  - User-visible outcome (if any): UI not updated
  - Evidence: Hypothesized

## Data and Storage

- What data is produced/consumed: Transcript text, timestamps, confidence, source
- Where it is stored (DB/files/userData/etc.): In-memory transcriptSegments array
- Retention / deletion controls (if documented): None, in-memory only

## Observability

- Logs/events emitted: None evidenced for individual results
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): asrLastSeenBySource timestamps

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How are partial vs final segments differentiated in UI?
- Documentation gaps to fill: Transcript rendering logic
- Test gaps to add (note only, no implementation): Test malformed ASR message handling</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-004.md

# OBS-016 Concurrency Limiting Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Limits concurrent ASR sessions and manages audio chunk queues with backpressure to prevent resource exhaustion. Uses global session semaphore (max 10) and per-source bounded priority queues (mic: 100, system: 50).
- Boundaries crossed: Network / Process / Model
- Primary components (coarse list): ConcurrencyController (Python), ws_live_listener.py (Python), SessionState (Python)

## Triggers and Preconditions

- Triggers: WebSocket connection attempt, audio chunk reception during active session
- Preconditions: Backend server running, concurrency controller initialized, session slot available

## Sequence (Happy Path)

1. WebSocket connection accepted and authenticated
   - Evidence:
     - Code: server/api/ws_live_listener.py :: @router.websocket("/ws/live-listener") :: await websocket.accept()
     - Docs: docs/flow-atlas-20260211.md :: EXT-012 Backend Server Start

2. Acquire session slot from global concurrency controller semaphore
   - Evidence:
     - Code: server/api/ws_live_listener.py :: controller = get_concurrency_controller(); session_acquired = await controller.acquire_session(timeout=5.0)
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: PR5: Concurrency Limiting + Backpressure

3. If session limit reached, reject connection with capacity message
   - Evidence:
     - Code: server/api/ws_live_listener.py :: if not session_acquired: await ws_send(... "Server at capacity, please try again later")
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: Global session semaphore (max 10)

4. For each audio chunk received, check if source should be dropped under extreme load
   - Evidence:
     - Code: server/api/ws_live_listener.py :: if controller.should_drop_source(source): state.dropped_frames += 1
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: 5 backpressure levels

5. Submit chunk to per-source bounded priority queue (mic priority 1, system priority 2)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: success, dropped_oldest = await controller.submit_chunk(chunk, source)
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: Per-source bounded queues (mic: 100, system: 50)

6. If queue full, drop oldest chunk and add new chunk (keep newest audio)
   - Evidence:
     - Code: server/services/concurrency_controller.py :: except (asyncio.QueueFull, asyncio.TimeoutError): dropped = queue.get_nowait(); await queue.put(audio_chunk)
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: Priority processing (mic > system)

7. Process chunks from queues with inference semaphore held (single-threaded ASR)
   - Evidence:
     - Code: server/services/concurrency_controller.py :: async def process_with_inference_lock(self, processor)
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: Adaptive chunk sizing (2s → 4s → 8s)

8. On session end, release session slot back to semaphore
   - Evidence:
     - Code: server/api/ws_live_listener.py :: finally: controller.release_session()
     - Docs: docs/IMPLEMENTATION_COMPLETE_SUMMARY.md :: Global session semaphore (max 10)

## Inputs and Outputs

- Inputs: WebSocket connection requests, audio chunks with source metadata
- Outputs: Session acceptance/rejection, queued chunks for processing, dropped frame counts
- Side effects (writes, network calls, model loads, UI state changes): Session slots held in semaphore, chunks buffered in priority queues, dropped frame counters incremented

## Failure Modes

- Failure: Session acquisition timeout (5s)
  - Where detected: asyncio.wait_for(controller.acquire_session(), timeout=5.0) raises TimeoutError
  - Current handling (as evidenced): Connection rejected with capacity message
  - User-visible outcome (if any): WebSocket connection fails with "Server at capacity" error
  - Evidence: server/api/ws_live_listener.py :: except asyncio.TimeoutError: logger.warning(f"Session acquisition timeout")

- Failure: Queue submission timeout (0.1s)
  - Where detected: asyncio.wait_for(queue.put(audio_chunk), timeout=timeout) raises TimeoutError
  - Current handling (as evidenced): Drop oldest chunk, retry submission
  - User-visible outcome (if any): Silent frame drop, dropped_frames counter incremented
  - Evidence: server/services/concurrency_controller.py :: except (asyncio.QueueFull, asyncio.TimeoutError): dropped = queue.get_nowait()

- Failure: Source dropped under extreme overload
  - Where detected: controller.should_drop_source(source) returns True
  - Current handling (as evidenced): Skip chunk processing, increment dropped counter
  - User-visible outcome (if any): Audio gaps during overload, logged warning
  - Evidence: server/api/ws_live_listener.py :: if controller.should_drop_source(source): logger.warning(f"Dropping {source} due to extreme overload")

- Failure: Inference semaphore acquisition fails
  - Where detected: await self.\_infer_sem.acquire() blocks indefinitely
  - Current handling (as evidenced): Processing stalls until semaphore available
  - User-visible outcome (if any): Delayed transcription, potential timeouts
  - Evidence: server/services/concurrency_controller.py :: await self.\_infer_sem.acquire()

- Failure: Session release fails
  - Where detected: controller.release_session() called but semaphore corrupted
  - Current handling (as evidenced): Logged debug message, no error handling
  - User-visible outcome (if any): None, but may leak session slots
  - Evidence: server/api/ws_live_listener.py :: controller.release_session(); logger.debug(f"Released session slot")

## Data and Storage

- What data is produced/consumed: Audio chunks with priority metadata, session slots, queue depths
- Where it is stored (DB/files/userData/etc.): In-memory asyncio.Semaphore, asyncio.PriorityQueue objects
- Retention / deletion controls (if documented): Chunks processed and discarded, session slots released on disconnect

## Observability

- Logs/events emitted: Session acquisition/release debug logs, dropped frame warnings, overload warnings
- Correlation IDs / session IDs (if any): Session ID in logs
- Metrics/traces (if any): Queue depths, dropped frames, backpressure levels tracked in ConcurrencyMetrics
  Evidence: server/services/concurrency_controller.py :: logger.warning(f"Dropped oldest {dropped.source} chunk"); server/api/ws_live_listener.py :: logger.debug(f"Released session slot")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How are chunks retrieved from concurrency controller queues for processing? Is there a separate processing loop?
- Documentation gaps to fill: Integration between concurrency controller queues and ASR processing pipeline
- Test gaps to add (note only, no implementation): Session limit enforcement, queue overflow behavior, priority processing verification</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/OBS-016.md

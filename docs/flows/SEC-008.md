# SEC-008 Audio Data Movement

## Summary

- Origin: Mixed
- Status: Implemented
- Secure transmission of audio data from client to server using base64 encoding over WebSocket with TLS encryption for remote connections, ensuring audio privacy during transit.
- Boundaries crossed: UI / Network / Process
- Primary components (coarse list): Swift audio capture, WebSocket client, FastAPI server

## Triggers and Preconditions

- Triggers: Audio capture produces PCM data frames
- Preconditions: WebSocket connection established, audio session started

## Sequence (Happy Path)

1. Audio capture manager produces PCM16 audio frames
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AudioCaptureManager.swift :: audio capture callbacks
     - Code: macapp/MeetingListenerApp/Sources/MicrophoneCaptureManager.swift :: audio capture callbacks
2. Client encodes PCM bytes to base64 string
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: data.base64EncodedString() (line 197)
3. Client wraps in JSON message with type "audio" and source tag
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: payload creation (lines 193-198)
     - Docs: docs/WS_CONTRACT.md :: audio message format
4. WebSocket transmits JSON over TLS (for remote) or unencrypted (localhost)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: webSocketScheme (wss for remote)
     - Docs: docs/SECURITY.md :: Audio streamed over WebSocket. Production must use wss://
5. Server receives JSON message and extracts base64 data
   - Evidence:
     - Code: server/api/ws_live_listener.py :: payload.get("data", "") (line 777)
6. Server decodes base64 back to raw PCM bytes
   - Evidence:
     - Code: server/api/ws_live_listener.py :: base64.b64decode(b64_data) (line 779)
7. Server queues decoded PCM for ASR processing
   - Evidence:
     - Code: server/api/ws_live_listener.py :: q.put_nowait(chunk) (line 785)

## Inputs and Outputs

- Inputs: Raw PCM16 audio data from capture
- Outputs: Decoded PCM bytes for ASR processing
- Side effects (writes, network calls, model loads, UI state changes): Base64 encoding/decoding overhead, network transmission of audio data

## Failure Modes

- Failure: Base64 encoding fails on client
  - Where detected: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: base64EncodedString()
  - Current handling (as evidenced): Data loss (frame not sent)
  - User-visible outcome (if any): Minor audio gaps in transcription
  - Evidence: No error handling in sendAudioFrame
- Failure: Base64 decoding fails on server
  - Where detected: server/api/ws_live_listener.py :: base64.b64decode()
  - Current handling (as evidenced): Exception caught by outer try/catch, logged as error
  - User-visible outcome (if any): Audio frame dropped, minor transcription gap
  - Evidence: server/api/ws_live_listener.py :: try/catch around message processing
- Failure: Network transmission fails (TLS issues, connection drops)
  - Where detected: WebSocket layer
  - Current handling (as evidenced): Connection resilience handles reconnection
  - User-visible outcome (if any): Temporary audio loss during reconnection
  - Evidence: docs/flows/NET-006.md :: WebSocket reconnection flow

## Data and Storage

- What data is produced/consumed: PCM16 audio bytes (16kHz, mono)
- Where it is stored (DB/files/userData/etc.): Transient in memory during transmission
- Retention / deletion controls (if documented): No retention, processed immediately

## Observability

- Logs/events emitted: Debug logs for audio frame size and source
- Correlation IDs / session IDs (if any): Session ID in WebSocket connection
- Metrics/traces (if any): Audio frame count metrics
  Evidence: server/api/ws_live_listener.py :: logger.debug for received audio

## Open Questions and Follow-up Tasks

- Questions: Is base64 encoding/decoding CPU overhead significant for real-time audio?
- Documentation gaps: Performance impact of base64 on audio latency
- Test gaps: Audio data integrity tests (corruption detection)
- Follow-up: Consider binary WebSocket frames for reduced overhead if TLS provides sufficient security

# INT-007 Real-Time Analysis Loop

## Summary
- Origin: Mixed
- Status: Implemented
- Periodic background task that runs every 40 seconds during active sessions, alternating between entity extraction (every 12s) and card extraction (every 28s), sending real-time analysis updates to client via WebSocket.
- Boundaries crossed: Process (thread pool for NLP) / Network (WebSocket updates)
- Primary components (coarse list): _analysis_loop task, analysis_stream.py functions, WebSocket

## Triggers and Preconditions
- Triggers: Session start (WebSocket connection established and session active)
- Preconditions: WebSocket session active, transcript has content, analysis task not cancelled

## Sequence (Happy Path)
Use numbered sequence. Each step must include evidence.
For each step:
1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Analysis loop task created on session start
   - Evidence:
     - Code: server/api/ws_live_listener.py :: state.analysis_tasks.append(asyncio.create_task(_analysis_loop(websocket, state)))
     - Docs: docs/flow-atlas-20260211.md :: ANALYSIS LOOP (Every 40s) → _analysis_loop() task created on session start

2. Loop sleeps for 12 seconds
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await asyncio.sleep(12)

3. Snapshot current transcript segments
   - Evidence:
     - Code: server/api/ws_live_listener.py :: snapshot = list(state.transcript)

4. Extract entities with 10s timeout in thread pool
   - Evidence:
     - Code: server/api/ws_live_listener.py :: entities = await asyncio.wait_for(asyncio.to_thread(extract_entities, snapshot), timeout=10.0)
     - Docs: docs/flow-atlas-20260211.md :: sleep 12s → extract_entities(transcript_snapshot) → 10s timeout enforced

5. Send entities_update WebSocket message to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, {"type": "entities_update", **entities})
     - Docs: docs/flow-atlas-20260211.md :: Send {"type":"entities_update",...}

6. Loop sleeps for 28 seconds
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await asyncio.sleep(28)

7. Snapshot current transcript segments again
   - Evidence:
     - Code: server/api/ws_live_listener.py :: snapshot = list(state.transcript)

8. Extract cards with 15s timeout in thread pool
   - Evidence:
     - Code: server/api/ws_live_listener.py :: cards = await asyncio.wait_for(asyncio.to_thread(extract_cards, snapshot), timeout=15.0)
     - Docs: docs/flow-atlas-20260211.md :: sleep 28s → extract_cards(transcript_snapshot) → 15s timeout enforced

9. Send cards_update WebSocket message to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, {"type": "cards_update", "actions": cards.get("actions", []), ...})
     - Docs: docs/flow-atlas-20260211.md :: Send {"type":"cards_update",...}

10. Loop repeats indefinitely until task cancelled
    - Evidence:
      - Code: server/api/ws_live_listener.py :: while True: ... except asyncio.CancelledError: return

## Inputs and Outputs
- Inputs: Current transcript segments (list of dict with text, timestamps)
- Outputs: WebSocket entities_update message (every 12s), cards_update message (every 28s)
- Side effects (writes, network calls, model loads, UI state changes): WebSocket messages sent to client, NLP processing in thread pool

## Failure Modes
List 5–10 realistic failures:
- Failure: Entity extraction timeout (10s)
  - Where detected: server/api/ws_live_listener.py :: asyncio.TimeoutError
  - Current handling: Warning logged "Entity extraction timed out after 10s, skipping this cycle", status message sent "Analysis delayed"
  - User-visible outcome: Entities not updated for this cycle, warning shown
  - Evidence: server/api/ws_live_listener.py :: logger.warning(...); await ws_send(... "status", "warning")

- Failure: Card extraction timeout (15s)
  - Where detected: server/api/ws_live_listener.py :: asyncio.TimeoutError
  - Current handling: Warning logged "Card extraction timed out after 15s, skipping this cycle", empty cards sent
  - User-visible outcome: Cards not updated for this cycle
  - Evidence: server/api/ws_live_listener.py :: logger.warning(...); cards = {"actions": [], "decisions": [], "risks": []}

- Failure: WebSocket send failure for entities_update
  - Where detected: ws_send function
  - Current handling: Exception propagates, may cancel task
  - User-visible outcome: Client stops receiving entity updates
  - Evidence: Assumed from async nature, no explicit handling seen

- Failure: WebSocket send failure for cards_update
  - Where detected: ws_send function
  - Current handling: Exception propagates, may cancel task
  - User-visible outcome: Client stops receiving card updates
  - Evidence: Assumed from async nature, no explicit handling seen

- Failure: Transcript snapshot empty or malformed
  - Where detected: extract_entities/extract_cards functions
  - Current handling: Functions handle empty input gracefully
  - User-visible outcome: Empty updates sent
  - Evidence: Assumed from function design, no explicit error handling seen

## Data and Storage
- What data is produced/consumed: Transcript snapshots (in-memory), extracted entities and cards (temporary)
- Where it is stored (DB/files/userData/etc.): In-memory only, not persisted
- Retention / deletion controls (if documented): Data discarded after WebSocket send

## Observability
- Logs/events emitted: Warning logs for timeouts, WebSocket entities_update and cards_update events
- Correlation IDs / session IDs (if any): None specific
- Metrics/traces (if any): None specific to this flow
Evidence: server/api/ws_live_listener.py :: logger.warning; WebSocket message types

## Open Questions and Follow-up Tasks
- Questions that cannot be answered from current evidence: What happens if WebSocket disconnects during loop? How are exceptions in extract_* functions handled?
- Documentation gaps to fill: Error handling for WebSocket send failures
- Test gaps to add (note only, no implementation): Test timeout scenarios, test WebSocket disconnection during loop
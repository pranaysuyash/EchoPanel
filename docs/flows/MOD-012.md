# MOD-012 Voxtral Streaming Session with Auto-Recovery

## Summary

- Origin: Code-only
- Status: Implemented
- Streaming ASR session management for Voxtral provider with automatic recovery from process failures during transcription.
- Boundaries crossed: Process, Model
- Primary components (coarse list): VoxtralRealtimeProvider, StreamingSession

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): transcribe_stream() called on VoxtralRealtimeProvider
- Preconditions (permissions, settings flags, availability, model cached, etc.): Provider is_available (binary and model exist)

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. \_ensure_session() checks if session exists and process alive
   - Evidence:
     - Code: server/services/provider_voxtral_realtime.py :: if self.\_session is None or self.\_session.process.returncode is not None

1. If no valid session, \_start_session() launches voxtral.c subprocess in streaming mode
   - Evidence:
     - Code: server/services/provider_voxtral_realtime.py :: self.\_session = await self.\_start_session()

1. Audio chunks written to subprocess stdin via \_write_chunk()
   - Evidence:
     - Code: server/services/provider_voxtral_realtime.py :: await self.\_write_chunk(session, audio_bytes, sample_rate)

1. On write error (BrokenPipeError), \_stop_session() terminates process, then \_ensure_session() starts new one
   - Evidence:
     - Code: server/services/provider_voxtral_realtime.py :: except RuntimeError as e: await self.\_stop_session(); session = await self.\_ensure_session()

1. Transcription results read from subprocess stdout asynchronously
   - Evidence:
     - Code: server/services/provider_voxtral_realtime.py :: text = await self.\_read_transcription(session, timeout=0.5)

## Inputs and Outputs

- Inputs: PCM audio stream, sample_rate, source metadata
- Outputs: AsyncIterator of ASRSegment objects with transcribed text, timestamps, confidence
- Side effects (writes, network calls, model loads, UI state changes): Subprocess stdin/stdout communication, process lifecycle management

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Voxtral binary not found
  - Where detected: is_available property
  - Current handling (as evidenced): Returns False, yields error segment
  - User-visible outcome (if any): "[Voxtral ASR unavailable]" in transcription
  - Evidence: server/services/provider_voxtral_realtime.py :: if not self.is_available: yield ASRSegment(text="[Voxtral ASR unavailable]")

- Failure: Model directory missing
  - Where detected: is_available property
  - Current handling (as evidenced): Returns False, same error handling
  - User-visible outcome (if any): Same unavailable message
  - Evidence: server/services/provider_voxtral_realtime.py :: model={self.\_model.exists()}

- Failure: Process startup fails
  - Where detected: \_start_session()
  - Current handling (as evidenced): Exception propagates, session remains None
  - User-visible outcome (if any): Transcription fails
  - Evidence: server/services/provider_voxtral_realtime.py :: process = await asyncio.create_subprocess_exec(...)

- Failure: Stdin pipe broken during write
  - Where detected: \_write_chunk()
  - Current handling (as evidenced): RuntimeError raised, triggers session restart
  - User-visible outcome (if any): Brief interruption, automatic recovery
  - Evidence: server/services/provider_voxtral_realtime.py :: except (BrokenPipeError, ConnectionResetError) as e: raise RuntimeError

- Failure: Stdout read times out
  - Where detected: \_read_transcription()
  - Current handling (as evidenced): Returns None, continues reading loop
  - User-visible outcome (if any): Delayed transcription output
  - Evidence: server/services/provider_voxtral_realtime.py :: except asyncio.TimeoutError: return None

## Data and Storage

- What data is produced/consumed: PCM audio chunks, transcribed text segments, timing metrics (chunks_processed, avg_infer_ms)
- Where it is stored (DB/files/userData/etc.): In-memory StreamingSession object (\_session), metrics accumulated during session
- Retention / deletion controls (if documented): Session retained until \_stop_session() called or process dies

## Observability

- Logs/events emitted: Session start/stop logs with metrics, write error logs triggering recovery
- Correlation IDs / session IDs (if any): None evidenced
- Metrics/traces (if any): Chunks processed, average inference time, realtime factor calculated
  Evidence required: server/services/provider_voxtral_realtime.py :: self.log(f"Starting voxtral.c streaming session"); self.log(f"Write error, restarting session")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How does session recovery affect transcription continuity?
- Documentation gaps to fill: Recovery triggers and success rates
- Test gaps to add (note only, no implementation): Process crash simulation, recovery latency measurement</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/MOD-012.md

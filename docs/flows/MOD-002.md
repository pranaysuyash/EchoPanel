# MOD-002 Registry Pattern with Thread-Safe Caching

## Summary

- Origin: Code-only
- Status: Implemented
- 1â€“2 sentence description: Provides thread-safe ASR provider registration and instance caching to ensure singleton provider instances with configuration-specific keys.
- Boundaries crossed: Process (module imports), Model (provider instantiation), Storage (in-memory caching)
- Primary components (coarse list): ASRProviderRegistry, provider modules, ASRConfig

## Triggers and Preconditions

- Triggers: Provider module import (registration), get_provider() call (discovery)
- Preconditions: Provider implements ASRProvider ABC, configuration is valid

## Sequence (Happy Path)

1. **Provider registration at import**
   - Each provider module calls ASRProviderRegistry.register() at import time
   - Stores provider class by name in \_providers dict
   - Evidence:
     - Code: provider_faster_whisper.py:307, provider_whisper_cpp.py:376-379, provider_voxtral_realtime.py:451
     - Docs: docs/audit/asr-model-lifecycle-20260211.md:213

2. **Provider instance request**
   - get_provider() called with optional name and ASRConfig
   - If name not provided, uses ECHOPANEL_ASR_PROVIDER env var or default
   - Evidence:
     - Code: asr_providers.py:322-323
     - Docs: docs/audit/asr-model-lifecycle-20260211.md:220

3. **Configuration key generation**
   - Creates unique key from provider name + config parameters
   - Key format: "name|model|device|compute_type|vad_enabled|chunk_seconds"
   - Evidence:
     - Code: asr_providers.py:329
     - Docs: docs/audit/asr-model-lifecycle-20260211.md:223

4. **Thread-safe instance lookup/creation**
   - Acquire registry lock to prevent race conditions
   - Check if instance exists for config key
   - If not, create new provider instance with config
   - Evidence:
     - Code: asr_providers.py:332-335
     - Docs: docs/audit/asr-model-lifecycle-20260211.md:226

5. **Provider initialization**
   - Call provider.**init**() with ASRConfig
   - Provider loads model if needed (lazy loading)
   - Evidence:
     - Code: provider_faster_whisper.py:44-50
     - Docs: docs/audit/asr-model-lifecycle-20260211.md:230

## Inputs and Outputs

- Inputs:
  - Provider name (string)
  - ASRConfig object (model, device, compute_type, etc.)
- Outputs:
  - ASRProvider instance (cached singleton per config)
- Side effects: Provider instances cached in memory, model loading triggered

## Failure Modes

- Failure: Provider not registered
  - Where detected: name not in \_providers dict
  - Current handling: Returns None
  - User-visible outcome: Provider unavailable error
  - Evidence: asr_providers.py:326

- Failure: Provider class initialization fails
  - Where detected: Exception in provider.**init**()
  - Current handling: Propagates exception to caller
  - User-visible outcome: ASR initialization failure
  - Evidence: asr_providers.py:334

- Failure: Invalid configuration
  - Where detected: Provider validates config in **init**
  - Current handling: Raises ValueError/TypeError
  - User-visible outcome: Configuration error
  - Evidence: provider_faster_whisper.py:44-50

- Failure: Provider dependencies missing
  - Where detected: is_available() returns False
  - Current handling: Provider not registered or returns None
  - User-visible outcome: Fallback to available provider
  - Evidence: asr_providers.py:344

- Failure: Lock acquisition timeout
  - Where detected: threading.Lock contention
  - Current handling: Blocks until lock available
  - User-visible outcome: Temporary delay in provider creation
  - Evidence: asr_providers.py:332

- Failure: Config key collision
  - Where detected: Different configs hash to same key
  - Current handling: Both configs share same instance
  - User-visible outcome: Unexpected config reuse (rare)
  - Evidence: asr_providers.py:329

## Data and Storage

- What data is produced/consumed: Provider classes, config keys, provider instances
- Where it is stored: Class-level dicts (\_providers, \_instances), protected by lock
- Retention / deletion controls: Instances cached for server lifetime, no explicit cleanup

## Observability

- Logs/events emitted: Minimal (by design), availability via /capabilities endpoint
- Correlation IDs / session IDs: None
- Metrics/traces: Provider availability exposed via get_provider_info()
- Evidence: main.py:159-174 (/capabilities endpoint)

## Open Questions and Follow-up Tasks

- Questions: How to handle provider unregistration or config changes?
- Documentation gaps: Config key collision probability, lock contention scenarios
- Test gaps: Concurrent provider requests, config key uniqueness

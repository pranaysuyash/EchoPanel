# INT-012 Post-Session Archival Analysis Flow

## Summary
- Origin: Doc-only
- Status: Hypothesized
- 1â€“2 sentence description: Runs high-accuracy NER and analysis on complete session transcript after session ends, using transformer models for better precision than real-time analysis.
- Boundaries crossed: Process (background task), Model (transformer NER), Storage (update session data)
- Primary components (coarse list): (hypothetical) archival_analyzer.py, background_task_manager.py

## Triggers and Preconditions
- Triggers: Session finalization completes, if archival analysis enabled in settings
- Preconditions: Session data saved to filesystem, archival flag set, system resources available

## Sequence (Happy Path)
1. Session ends and final summary sent to client
   - Evidence:
     - Docs: docs/NER_PIPELINE_ARCHITECTURE.md :: Post-Call phase (line 43)
     - Docs: docs/FULL_PIPELINE_DATA_FLOW.md :: Archival Mode (line 33)
2. Background task manager detects completed session and archival flag
   - Evidence:
     - Docs: docs/NER_PIPELINE_ARCHITECTURE.md :: Managed background Task (line 43)
3. Load complete transcript and existing analysis from stored session JSON
   - Evidence:
     - Docs: docs/FULL_PIPELINE_DATA_FLOW.md :: Full Index Optimization (line 37)
4. Run transformer-based NER (en_core_web_trf) on full transcript
   - Evidence:
     - Docs: docs/NER_PIPELINE_ARCHITECTURE.md :: en_core_web_trf (Transf.) (line 43)
5. Extract higher-accuracy entities and cards with improved confidence scores
   - Evidence:
     - Docs: docs/NER_PIPELINE_ARCHITECTURE.md :: Max accuracy (line 43)
6. Update stored session data with archival analysis results
   - Evidence:
     - Docs: docs/FULL_PIPELINE_DATA_FLOW.md :: Rerunning hybrid search (line 37)
7. Send completion notification to user (optional)
   - Evidence:
     - Assumed: Background task completion pattern

## Inputs and Outputs
- Inputs: Stored session JSON with transcript and initial analysis
- Outputs: Enhanced entities/cards dicts with higher confidence and additional detections
- Side effects (writes, network calls, model loads, UI state changes): Updates session JSON file, loads transformer model, possibly sends local notification

## Failure Modes
- Failure: Transformer model fails to load or initialize
  - Where detected: Background task execution
  - Current handling: (Hypothesized) Skip archival, log error, fall back to real-time results
  - User-visible outcome: No archival enhancement, session remains with real-time analysis
  - Evidence: Assumed based on model lifecycle patterns
- Failure: Storage I/O error when updating session data
  - Where detected: File write operation
  - Current handling: (Hypothesized) Retry with backoff, log error
  - User-visible outcome: Archival results lost, user notified of failure
  - Evidence: Assumed based on storage flow patterns
- Failure: Background task times out or is killed by system
  - Where detected: Task manager monitoring
  - Current handling: (Hypothesized) Mark as failed, allow manual retry
  - User-visible outcome: Incomplete archival analysis
  - Evidence: Assumed based on reliability flows

## Data and Storage
- What data is produced/consumed: Enhanced entity extractions, higher-confidence card detections, archival metadata
- Where it is stored (DB/files/userData/etc.): Updates existing session JSON files with archival fields
- Retention / deletion controls: Same as session data retention

## Observability
- Logs/events emitted: Background task start/completion/failure logs
- Correlation IDs / session IDs: Session ID in task logs
- Metrics/traces: (Hypothesized) Archival processing time, accuracy improvements
- Evidence: Assumed based on observability flows

## Open Questions and Follow-up Tasks
- Questions: When should archival trigger (immediate vs scheduled)? How to handle multiple archival passes? User control over archival?
- Documentation gaps: Detailed implementation plan, model selection criteria, performance benchmarks
- Test gaps: Background task integration tests, archival accuracy validation, resource usage monitoring
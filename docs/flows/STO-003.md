# STO-003 Session Auto-Save Snapshot

## Summary

- Origin: Code-only
- Status: Implemented
- Periodic auto-save of complete session state to snapshot.json every 30 seconds for crash recovery and session resumption.
- Boundaries crossed: Storage / UI
- Primary components (coarse list): Timer, snapshot.json, saveSnapshot(), auto-save notifications

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Timer fires every 30s, session active
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session started, current session directory exists

## Sequence (Happy Path)

1. Start auto-save timer on session start
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:133-142
     - Docs: docs/DECISIONS.md:14
2. Timer posts notification for auto-save request
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:135-137
     - Docs: docs/STORAGE_AND_EXPORTS.md:11
3. AppState responds to notification and calls saveSnapshot()
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:115-131
     - Docs: Assumed from notification pattern
4. Write current session data to snapshot.json with timestamp
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:117-129
     - Docs: docs/STORAGE_AND_EXPORTS.md:11
5. Stop timer on session end
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/SessionStore.swift:144-148
     - Docs: docs/STORAGE_AND_EXPORTS.md:12-13

## Inputs and Outputs

- Inputs: Current session state data, is_final flag
- Outputs: snapshot.json file with saved_at timestamp
- Side effects (writes, network calls, model loads, UI state changes): File writes, periodic saves

## Failure Modes

- Failure: Timer creation fails
  - Where detected: scheduledTimer()
  - Current handling (as evidenced): Timer may not start
  - User-visible outcome (if any): No auto-save
  - Evidence: SessionStore.swift:133-142
- Failure: Notification not posted
  - Where detected: Timer fire
  - Current handling (as evidenced): No save triggered
  - User-visible outcome (if any): Missed auto-save
  - Evidence: SessionStore.swift:135-137
- Failure: Snapshot data serialization fails
  - Where detected: JSONSerialization
  - Current handling (as evidenced): Log error, no save
  - User-visible outcome (if any): No auto-save
  - Evidence: SessionStore.swift:122-129
- Failure: File write fails
  - Where detected: write(to:)
  - Current handling (as evidenced): Log error
  - User-visible outcome (if any): No snapshot saved
  - Evidence: SessionStore.swift:122-129
- Failure: Timer invalidation fails
  - Where detected: invalidate()
  - Current handling (as evidenced): Timer continues (harmless)
  - User-visible outcome (if any): None
  - Evidence: SessionStore.swift:144-148

## Data and Storage

- What data is produced/consumed: Complete session state (transcript, cards, entities, metadata)
- Where it is stored (DB/files/userData/etc.): Local JSON file in session directory
- Retention / deletion controls (if documented): Overwritten on each save, kept until session end

## Observability

- Logs/events emitted: Save success/failure messages
- Correlation IDs / session IDs (if any): Session ID in logs
- Metrics/traces (if any): None specific
- Evidence: SessionStore.swift NSLog statements

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What triggers the actual save from the notification?
- Documentation gaps: Snapshot format versioning, merge conflicts on recovery
- Test gaps to add (note only, no implementation): Test timer accuracy, snapshot integrity</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/STO-003.md

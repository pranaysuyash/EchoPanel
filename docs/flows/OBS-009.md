# OBS-009 Backpressure Monitoring & Alerting Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Server monitors audio queue fill ratios every 1Hz and sends status alerts to client when backpressure thresholds are crossed.
- Boundaries crossed: Network (WebSocket status messages)
- Primary components (coarse list): ws_live_listener.py, ConcurrencyController

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Metrics emission loop (1Hz), queue operations
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session active, queues initialized

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Metrics loop calculates queue fill ratio per source
   - Evidence:
     - Code: server/api/ws_live_listener.py :: queue_depth / queue_max in \_metrics_loop
   - Notes: Fill ratio = current_depth / QUEUE_MAX

1. Check if fill ratio exceeds buffering threshold (0.85)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: if fill_ratio > 0.85 and not state.backpressure_warned
   - Notes: First warning level

1. Send "buffering" status message to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, {"state": "buffering", "message": "Processing backlog for {source}"})
   - Notes: Indicates processing delay

1. Check if fill ratio exceeds critical threshold (0.95)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: if fill_ratio > 0.95 and not state.backpressure_warned
   - Notes: Higher warning level

1. Send "overloaded" status message to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, {"state": "overloaded", "message": "Audio backlog critical for {source}"})
   - Notes: Indicates critical backlog

1. Client receives status message and updates UI
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: case "status": onStatus callback
   - Notes: Shows buffering/overloaded state

1. Backpressure clears when fill ratio drops below 0.70
   - Evidence:
     - Code: server/api/ws_live_listener.py :: elif fill_ratio < 0.70: state.backpressure_warned = False
   - Notes: Resets warning flag for future alerts

1. Process repeats every 1 second during session
   - Evidence:
     - Code: server/api/ws_live_listener.py :: while True: await asyncio.sleep(1.0)
   - Notes: Continuous monitoring

## Inputs and Outputs

- Inputs:
  - Queue depth measurements
  - Fill ratio thresholds (0.70, 0.85, 0.95)
- Outputs:
  - WebSocket status messages ("buffering", "overloaded")
- Side effects (writes, network calls, model loads, UI state changes): Status messages sent, UI backpressure indicators

## Failure Modes

List 5–10 realistic failures:

- Failure: Metrics loop crashes
  - Where detected: Exception in \_metrics_loop
  - Current handling (as evidenced): Logged error, loop terminates
  - User-visible outcome (if any): No backpressure alerts
  - Evidence: Code: server/api/ws_live_listener.py :: except Exception as e: logger.error

- Failure: WebSocket send fails for status message
  - Where detected: ws_send raises exception
  - Current handling (as evidenced): Exception propagates, may crash loop
  - User-visible outcome (if any): Client unaware of backpressure
  - Evidence: Code: server/api/ws_live_listener.py :: await ws_send() in try block

- Failure: Queue size calculation fails
  - Where detected: q.qsize() throws
  - Current handling (as evidenced): Exception in loop, logged
  - User-visible outcome (if any): No monitoring for that source
  - Evidence: Code: server/api/ws_live_listener.py :: except Exception as e

- Failure: Backpressure warning spam
  - Where detected: Multiple messages sent rapidly
  - Current handling (as evidenced): backpressure_warned flag prevents repeat sends
  - User-visible outcome (if any): Single alert per backpressure episode
  - Evidence: Code: server/api/ws_live_listener.py :: not state.backpressure_warned check

- Failure: Client ignores status messages
  - Where detected: Status message received but not processed
  - Current handling (as evidenced): Treated as normal streaming status
  - User-visible outcome (if any): UI doesn't show backpressure
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: "backpressure" → .streaming

## Data and Storage

- What data is produced/consumed: Queue depths, fill ratios, warning flags
- Where it is stored (DB/files/userData/etc.): In-memory session state
- Retention / deletion controls (if documented): Per-session, cleared on disconnect

## Observability

- Logs/events emitted: Status messages logged, error logging on failures
- Correlation IDs / session IDs (if any): Included in status messages
- Metrics/traces (if any): Fill ratios in metrics payload
- Evidence: Code: server/api/ws_live_listener.py :: logger in status sends

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: None
- Documentation gaps to fill: None
- Test gaps to add (note only, no implementation): Test backpressure alerting at different thresholds

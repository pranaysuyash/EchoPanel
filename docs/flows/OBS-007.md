# OBS-007 Metrics Emission Flow (1Hz)

## Summary

- Origin: Code-only
- Status: Implemented
- Server emits real-time processing metrics to client every 1 second via WebSocket for health monitoring and UI updates.
- Boundaries crossed: Network (WebSocket)
- Primary components (coarse list): ws_live_listener.py, WebSocketStreamer

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): WebSocket session established, metrics task started
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session state active, queues initialized

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Metrics loop task created on session start
   - Evidence:
     - Code: server/api/ws_live_listener.py :: state.metrics_task = asyncio.create_task(\_metrics_loop(websocket, state))
   - Notes: Runs asynchronously per session

1. Loop sleeps for 1 second interval
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await asyncio.sleep(1.0)
   - Notes: 1Hz emission rate

1. Queue and processing metrics calculated per source
   - Evidence:
     - Code: server/api/ws_live_listener.py :: queue_depth = q.qsize(), avg_infer_time from state.asr_processing_times[-10:]
   - Notes: Real-time factor, backlog calculations

1. Metrics payload assembled with correlation IDs
   - Evidence:
     - Code: server/api/ws_live_listener.py :: metrics_payload dict with session_id, attempt_id, source, queue_depth, etc.
   - Notes: Includes provider, model, VAD status

1. Payload sent via WebSocket to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, metrics_payload)
   - Notes: "metrics" message type

1. Client receives and parses metrics message
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: case "metrics": parse SourceMetrics
   - Notes: Calls onMetrics callback

1. Process repeats every 1 second until session ends
   - Evidence:
     - Code: server/api/ws_live_listener.py :: while True: loop
   - Notes: Continues until state.closed or exception

## Inputs and Outputs

- Inputs:
  - Queue states, processing times, dropped counts
  - Session correlation IDs, provider/model info
- Outputs:
  - WebSocket "metrics" messages to client
  - SourceMetrics objects to client callback
- Side effects (writes, network calls, model loads, UI state changes): WebSocket message emission, client UI updates

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Metrics loop crashes with exception
  - Where detected: Exception in \_metrics_loop
  - Current handling (as evidenced): Logged error, loop terminates
  - User-visible outcome (if any): No more metrics emission for session
  - Evidence: Code: server/api/ws_live_listener.py :: except Exception as e: logger.error

- Failure: WebSocket send fails during emission
  - Where detected: ws_send raises exception
  - Current handling (as evidenced): Exception propagates, crashes loop
  - User-visible outcome (if any): Metrics stop, session may disconnect
  - Evidence: Code: server/api/ws_live_listener.py :: await ws_send() in try block

- Failure: Session closed before emission
  - Where detected: state.closed check
  - Current handling (as evidenced): Loop returns early
  - User-visible outcome (if any): Clean shutdown
  - Evidence: Code: server/api/ws_live_listener.py :: if state.closed: return

- Failure: Queue access fails
  - Where detected: q.qsize() throws
  - Current handling (as evidenced): Exception in loop, logged
  - User-visible outcome (if any): Metrics emission stops
  - Evidence: Code: server/api/ws_live_listener.py :: except Exception as e

- Failure: Client doesn't receive metrics
  - Where detected: WebSocket message lost
  - Current handling (as evidenced): No retry, silent failure
  - User-visible outcome (if any): Stale metrics in UI
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: no error handling for metrics parsing

## Data and Storage

- What data is produced/consumed: Queue depths, processing times, dropped counts, correlation IDs
- Where it is stored (DB/files/userData/etc.): In-memory session state, WebSocket message
- Retention / deletion controls (if documented): Metrics not persisted, live only

## Observability

- Logs/events emitted: Error logging on loop crash
- Correlation IDs / session IDs (if any): Included in metrics payload
- Metrics/traces (if any): The metrics themselves are observability data
- Evidence: Code: server/api/ws_live_listener.py :: logger.error in except block

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: None
- Documentation gaps to fill: None
- Test gaps to add (note only, no implementation): Test metrics emission under network failure

# NET-007 WebSocket Backpressure Handling

## Summary

- Origin: Code-only
- Status: Implemented
- Client receives backpressure status messages from server and adjusts behavior accordingly, while server manages audio queue overflow.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, ws_live_listener.py, ConcurrencyController

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Server detects audio queue overflow or high fill ratio
- Preconditions (permissions, settings flags, availability, model cached, etc.): WebSocket connection established, audio streaming active

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Server detects queue fill ratio > 0.85 or frame drops occur
   - Evidence:
     - Code: server/api/ws_live_listener.py :: fill_ratio > 0.85 check in metrics emission, dropped_oldest flag from controller.submit_chunk()
     - Docs: docs/REALTIME_STREAMING_ARCHITECTURE.md :: Backpressure handling
   - Notes: Multiple thresholds: 0.85 for buffering, 0.95 for overloaded

1. Server sends backpressure status message to client
   - Evidence:
     - Code: server/api/ws_live_listener.py :: ws_send() with "state": "backpressure" or "buffering" or "overloaded"
     - Docs: docs/WS_CONTRACT.md :: status message with state and message fields
   - Notes: Throttled to avoid spam (backpressure_warned flag)

1. Client receives status message and treats as streaming state
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleJSON() case "status", treats "backpressure" as .streaming
   - Notes: Client doesn't change behavior, just notifies UI

1. UI displays backpressure warning to user
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: backpressureLevel updated based on metrics
   - Notes: Visual indication of system load

1. Server continues dropping oldest frames under extreme load
   - Evidence:
     - Code: server/services/concurrency_controller.py :: submit_chunk() drops oldest when queue full
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Queue overflow → frame drops, backpressure logging
   - Notes: Prevents memory exhaustion

1. Backpressure clears when fill ratio < 0.70
   - Evidence:
     - Code: server/api/ws_live_listener.py :: elif fill_ratio < 0.70: state.backpressure_warned = False
   - Notes: Resets warning state for future alerts

## Inputs and Outputs

- Inputs:
  - Audio chunks from client
  - Queue fill ratio metrics
- Outputs:
  - Status messages ("backpressure", "buffering", "overloaded")
  - Dropped frame counts
- Side effects (writes, network calls, model loads, UI state changes): Status messages sent over WebSocket, UI backpressure indicators updated

## Failure Modes

List 5–10 realistic failures:

- Failure: Client ignores backpressure messages
  - Where detected: Client continues sending at high rate
  - Current handling (as evidenced): No client-side rate limiting implemented
  - User-visible outcome (if any): Continued frame drops, persistent warnings
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: treats backpressure as normal streaming

- Failure: Server backpressure detection fails
  - Where detected: Queue overflows without warning
  - Current handling (as evidenced): Metrics emission runs every 1Hz, may miss brief spikes
  - User-visible outcome (if any): Silent frame drops
  - Evidence: Code: server/api/ws_live_listener.py :: metrics emission in 1Hz timer

- Failure: WebSocket message delivery fails during backpressure
  - Where detected: Status message send fails
  - Current handling (as evidenced): Async task creation, no retry logic
  - User-visible outcome (if any): Client unaware of backpressure
  - Evidence: Code: server/api/ws_live_listener.py :: asyncio.create_task(ws_send())

- Failure: Extreme overload causes all sources dropped
  - Where detected: should_drop_source() returns true
  - Current handling (as evidenced): Source dropped silently, frames not queued
  - User-visible outcome (if any): Audio stops for that source
  - Evidence: Code: server/services/concurrency_controller.py :: should_drop_source()

- Failure: Backpressure warning spam
  - Where detected: Multiple warnings sent rapidly
  - Current handling (as evidenced): backpressure_warned flag prevents spam
  - User-visible outcome (if any): Single warning per backpressure episode
  - Evidence: Code: server/api/ws_live_listener.py :: not state.backpressure_warned check

## Data and Storage

- What data is produced/consumed: Queue fill ratios, dropped frame counts, backpressure warning state
- Where it is stored (DB/files/userData/etc.): In-memory in SessionState and ConcurrencyController
- Retention / deletion controls (if documented): Cleared on session end

## Observability

- Logs/events emitted: Warning logs for dropped frames, backpressure status messages
- Correlation IDs / session IDs (if any): Included in status messages
- Metrics/traces (if any): audio_frames_dropped counter, queue_fill_ratio gauge
  Evidence: Code: server/services/metrics_registry.py :: inc_counter("audio_frames_dropped")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: Does client implement any rate limiting based on backpressure?
- Documentation gaps to fill: Client-side backpressure response behavior
- Test gaps to add (note only, no implementation): Load test to verify backpressure thresholds work correctly</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-007.md

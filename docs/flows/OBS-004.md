# OBS-004 Backend Health Check Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Client polls backend /health endpoint every 1s until server reports ASR ready, then stops polling and updates UI with provider/model info.
- Boundaries crossed: Network (HTTP requests)
- Primary components (coarse list): BackendManager, health endpoint in main.py

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Backend server process started
- Preconditions (permissions, settings flags, availability, model cached, etc.): Backend process running on configured port

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Backend process starts, health check timer begins
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: startHealthCheck() schedules 1s timer
     - Docs: docs/IMPLEMENTATION_SUMMARY_OBSERVABILITY.md :: Backend health polling
   - Notes: Polls until server ready

1. Client sends HTTP GET to /health endpoint
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: URLSession.shared.dataTask(with: healthCheckURL)
     - Docs: docs/WS_CONTRACT.md :: Health check endpoint
   - Notes: Uses configurable timeout (default 2s)

1. Server checks ASR provider and model readiness
   - Evidence:
     - Code: server/main.py :: health_check() calls provider.is_available and model_health.ready
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Basic health check checks ASR provider availability
   - Notes: Deep health check requires both provider and model

1. Server returns 200 OK with provider/model details
   - Evidence:
     - Code: server/main.py :: return {"status": "ok", "provider": provider_name, "model": config.model_name}
   - Notes: Includes load/warmup times

1. Client receives 200, updates status to running
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: statusCode == 200 && status == "ok" → serverStatus = .running
   - Notes: Stops health check timer

1. UI displays provider/model info in health detail
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: healthDetail = "ASR: \(provider) (\(model))"
   - Notes: User sees "ASR: faster-whisper (large-v3)"

## Inputs and Outputs

- Inputs:
  - Backend URL and port configuration
  - Health check timeout (configurable)
- Outputs:
  - Server status updates (.running, .runningNeedsSetup, .error)
  - Health detail string for UI
- Side effects (writes, network calls, model loads, UI state changes): HTTP requests every 1s, UI status updates

## Failure Modes

List 5–10 realistic failures:

- Failure: Server returns 503 (not ready)
  - Where detected: statusCode == 503
  - Current handling (as evidenced): serverStatus = .runningNeedsSetup, continues polling
  - User-visible outcome (if any): "Backend not ready" message
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: statusCode == 503 handling

- Failure: Network timeout or connection refused
  - Where detected: URLSession error
  - Current handling (as evidenced): healthDetail = error.localizedDescription, continues polling
  - User-visible outcome (if any): Error message in UI
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: if let error { healthDetail = error.localizedDescription }

- Failure: Server crashes during health check
  - Where detected: No response to HTTP request
  - Current handling (as evidenced): Error triggers recovery flow
  - User-visible outcome (if any): Server restart attempt
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: error handling leads to recovery

- Failure: Model fails to load
  - Where detected: model_health.ready == False
  - Current handling (as evidenced): Server returns 503 with reason
  - User-visible outcome (if any): "Model loading" or error message
  - Evidence: Code: server/main.py :: if not model_health.ready: reason = f"Model {model_health.state.name.lower()}"

- Failure: Provider not available
  - Where detected: provider.is_available == False
  - Current handling (as evidenced): Server returns 503
  - User-visible outcome (if any): "ASR provider not available"
  - Evidence: Code: server/main.py :: else: reason = "ASR provider not available"

## Data and Storage

- What data is produced/consumed: Provider name, model name, model state, load/warmup times
- Where it is stored (DB/files/userData/etc.): In-memory in BackendManager, displayed in UI
- Retention / deletion controls (if documented): Updated on each health check, cleared on server stop

## Observability

- Logs/events emitted: Server logs "Health check requested" on debug level
- Correlation IDs / session IDs (if any): None (health checks are global)
- Metrics/traces (if any): None (health checks not metered)
  Evidence: Code: server/main.py :: logger.debug("Health check requested.")

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What happens if health checks fail indefinitely?
- Documentation gaps to fill: Health check failure thresholds and escalation
- Test gaps to add (note only, no implementation): Test health check behavior during model loading


# INT-006 Session-End Final Analysis Flow

## Summary
- Origin: Mixed
- Status: Implemented
- Performs final NLP analysis (diarization, summary, entity extraction, card extraction) on complete session transcript after ASR flush and sends final summary to client.
- Boundaries crossed: Process (analysis tasks) / Network (WebSocket final_summary) / Storage (transcript access)
- Primary components (coarse list): ws_live_listener, analysis_stream, diarization

## Triggers and Preconditions
- Triggers: WebSocket "stop" message received from client
- Preconditions: Active session with ASR tasks running, transcript available

## Sequence (Happy Path)
Use numbered sequence. Each step must include evidence.
For each step:
1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Backend receives WebSocket "stop" message
   - Evidence:
     - Code: server/api/ws_live_listener.py :: elif msg_type == "stop"
     - Docs: docs/FLOW_ATLAS.md :: AI-006: Session-End Final Analysis Pipeline

2. Signal EOF to all audio queues to stop ASR processing
   - Evidence:
     - Code: server/api/ws_live_listener.py :: for q in state.queues.values(): await q.put(None)

3. Wait for ASR tasks to flush final transcriptions (8s timeout)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: await asyncio.wait_for(asyncio.gather(*state.asr_tasks), timeout=8)
     - Docs: docs/flows/EXT-005.md :: Backend waits for ASR tasks to flush final transcriptions

4. Cancel running analysis tasks (5s timeout)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: for t in state.analysis_tasks: t.cancel(); await asyncio.wait_for(asyncio.gather(*state.analysis_tasks), timeout=5.0)

5. Run session-end diarization per audio source
   - Evidence:
     - Code: server/api/ws_live_listener.py :: diarization_by_source = await _run_diarization_per_source(state)
     - Docs: docs/FLOW_ATLAS.md :: For each source: run_diarization()

6. Sort transcript by timestamp for deterministic ordering
   - Evidence:
     - Code: server/api/ws_live_listener.py :: transcript_snapshot = sorted(state.transcript, key=lambda s: s.get("t0", 0.0))
     - Docs: docs/flows/EXT-005.md :: P1 fix (TO-1): Sort by timestamp

7. Merge transcript with source-specific speaker labels
   - Evidence:
     - Code: server/api/ws_live_listener.py :: labeled_transcript = await asyncio.to_thread(_merge_transcript_with_source_diarization, transcript_snapshot, diarization_by_source)

8. Generate final rolling summary as markdown
   - Evidence:
     - Code: server/api/ws_live_listener.py :: summary_md = await asyncio.to_thread(generate_rolling_summary, transcript_snapshot)
     - Code: server/services/analysis_stream.py :: def generate_rolling_summary

9. Extract final cards (actions/decisions/risks)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: cards = await asyncio.to_thread(extract_cards, transcript_snapshot)
     - Code: server/services/analysis_stream.py :: extract_cards

10. Extract final entities
    - Evidence:
      - Code: server/api/ws_live_listener.py :: entities = await asyncio.to_thread(extract_entities, transcript_snapshot)
      - Code: server/services/analysis_stream.py :: extract_entities

11. Send final_summary WebSocket message with complete data
    - Evidence:
      - Code: server/api/ws_live_listener.py :: await ws_send(state, websocket, {"type": "final_summary", "markdown": summary_md, "json": {...}})
      - Docs: docs/flows/EXT-005.md :: Backend sends final_summary message

12. Close WebSocket connection
    - Evidence:
      - Code: server/api/ws_live_listener.py :: await websocket.close()

## Inputs and Outputs
- Inputs: Transcript snapshot (list of dict), diarization audio buffers per source
- Outputs: Final summary markdown string, JSON object with session_id, transcript, actions, decisions, risks, entities, diarization segments
- Side effects (writes, network calls, model loads, UI state changes): WebSocket message sent, connection closed, analysis models loaded if not cached

## Failure Modes
List 5â€“10 realistic failures:
- Failure: ASR flush timeout (8s)
  - Where detected: server/api/ws_live_listener.py :: asyncio.TimeoutError
  - Current handling: Warning log, status message to client "ASR processing timed out, some speech may be missing"
  - User-visible outcome: Partial transcript in final summary
  - Evidence: server/api/ws_live_listener.py :: logger.warning("ASR flush timed out..."); await ws_send(... "warning")

- Failure: Analysis task cancellation timeout (5s)
  - Where detected: server/api/ws_live_listener.py :: asyncio.TimeoutError
  - Current handling: Warning log "Analysis task cancellation timed out, some tasks may be orphaned"
  - User-visible outcome: None (orphaned tasks may consume resources)
  - Evidence: server/api/ws_live_listener.py :: logger.warning("Analysis task cancellation timed out...")

- Failure: Diarization processing failure
  - Where detected: _run_diarization_per_source function
  - Current handling: Exception propagates, WebSocket closes without final_summary
  - User-visible outcome: Session fails to finalize, client shows error
  - Evidence: Assumed from code structure, no explicit handling seen

- Failure: Analysis function exceptions (generate_rolling_summary, extract_cards, extract_entities)
  - Where detected: asyncio.to_thread calls
  - Current handling: Exception propagates, WebSocket closes without final_summary
  - User-visible outcome: Session fails to finalize, client shows error
  - Evidence: Assumed from code structure, no explicit handling seen

- Failure: WebSocket send failure
  - Where detected: ws_send function
  - Current handling: Exception propagates, connection closes
  - User-visible outcome: Client doesn't receive final summary
  - Evidence: Assumed from async nature, no explicit handling seen

## Data and Storage
- What data is produced/consumed: Transcript segments, diarization segments, summary markdown, extracted entities and cards
- Where it is stored (DB/files/userData/etc.): In-memory during processing, persisted in session bundle JSON file via client
- Retention / deletion controls (if documented): Session bundles retained until user deletes, no automatic cleanup documented

## Observability
- Logs/events emitted: Debug logs for stop received, warnings for timeouts, final_summary WebSocket event
- Correlation IDs / session IDs (if any): session_id in final_summary JSON
- Metrics/traces (if any): None specific to this flow
Evidence: server/api/ws_live_listener.py :: logger.debug/logger.warning; WebSocket "final_summary" type

## Open Questions and Follow-up Tasks
- Questions that cannot be answered from current evidence: How are orphaned analysis tasks cleaned up? What happens if diarization fails?
- Documentation gaps to fill: Detailed failure handling for analysis functions
- Test gaps to add (note only, no implementation): Test ASR flush timeout scenario, test analysis function failures
# NET-003 Audio Data Transmission over WebSocket

## Summary

- Origin: Code-only
- Status: Implemented
- Captured PCM frames are encoded to JSON `audio` messages and sent via bounded async queue.
- Boundaries crossed: Audio capture -> Network
- Primary components (coarse list): AppState, AudioCaptureManager, MicrophoneCaptureManager, WebSocketStreamer

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): capture callbacks emit PCM frames
- Preconditions (permissions, settings flags, availability, model cached, etc.): active capture path and websocket task

## Sequence (Happy Path)

1. Capture callbacks receive PCM data from system and/or mic.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `audioCapture.onPCMFrame`, `micCapture.onPCMFrame`
2. App state records diagnostics and forwards frame to streamer.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `markInputFrame(...)` + `streamer.sendPCMFrame(frame, source: ...)`
3. Streamer builds `{"type":"audio","source":...,"data":base64}` payload.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `sendPCMFrame(_:,source:)`
4. JSON send is enqueued on single-threaded operation queue with cap.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `sendQueue.addOperation`, `maxQueuedSends = 100`
5. Operation sends websocket text frame, waits up to 5s for completion.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `task?.send(.string(text))`, semaphore timeout logic
6. Server consumes `audio` message format.
   - Evidence:
     - Docs: `docs/WS_CONTRACT.md` :: Client -> server `audio`

## Inputs and Outputs

- Inputs: PCM bytes, audio source tag (`system`/`mic`)
- Outputs: websocket JSON text frames
- Side effects (writes, network calls, model loads, UI state changes): queued sends, warning logs on overflow/timeout

## Failure Modes

- Failure: Queue overflow under sustained pressure
  - Where detected: pre-enqueue guard
  - Current handling (as evidenced): drop frame and log warning
  - User-visible outcome (if any): lower transcript completeness under overload
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: queue depth guard + warning log

- Failure: Send callback returns error
  - Where detected: websocket send completion
  - Current handling (as evidenced): routes to `handleError` and reconnection path
  - User-visible outcome (if any): reconnecting state
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `if let error = sendError { handleError(error) }`

- Failure: Send completion exceeds 5s wait
  - Where detected: semaphore timeout
  - Current handling (as evidenced): warning log; operation continues
  - User-visible outcome (if any): potential lag/frame loss before reconnect path engages
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `StructuredLogger.shared.warning("WebSocket send timeout", ...)`

- Failure: JSON serialization/string conversion fails
  - Where detected: `sendJSON`
  - Current handling (as evidenced): early return
  - User-visible outcome (if any): that frame is dropped
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `guard let data...`, `guard let text...`

## Data and Storage

- What data is produced/consumed: transient PCM frame payloads
- Where it is stored (DB/files/userData/etc.): in-memory send queue only
- Retention / deletion controls (if documented): queue entries discarded after send/cancel

## Observability

- Logs/events emitted: queue overflow warnings, send-timeout warnings, downstream status changes on errors
- Correlation IDs / session IDs (if any): connection context retained on streamer/logger
- Metrics/traces (if any): backend metrics path exists, no dedicated client frame-send metric counter

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: none
- Documentation gaps to fill: none
- Test gaps to add (note only, no implementation): deterministic test for queue overflow/drop behavior

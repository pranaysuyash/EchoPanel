# NET-003 Audio Data Transmission over WebSocket

## Summary

- Origin: Code-only
- Status: Hypothesized
- Client sends captured PCM audio frames to backend server via WebSocket for real-time ASR processing.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, AudioCaptureManager, MicrophoneCaptureManager

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Audio capture produces PCM frames
- Preconditions (permissions, settings flags, availability, model cached, etc.): WebSocket connected, audio capture active

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Audio capture produces PCM frame
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: audioCapture.onPCMFrame, micCapture.onPCMFrame
   - Notes: From AudioCaptureManager or MicrophoneCaptureManager

1. AppState receives frame and calls streamer.sendPCMFrame(frame, source)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: self.streamer.sendPCMFrame(frame, source: source)
   - Notes: Updates debug counters, marks input frame

1. WebSocketStreamer.sendPCMFrame encodes frame to base64
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: sendPCMFrame encodes Data(frame).base64EncodedString()
   - Notes: Creates JSON message {"type":"audio","source":"system|mic","data":"base64..."}

1. Message queued in sendQueue for async sending
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: sendQueue.addOperation with maxQueuedSends = 100
   - Notes: Bounded queue to prevent blocking capture thread

1. Operation sends message via WebSocket
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: task?.send(.string(jsonString))
   - Notes: Uses URLSessionWebSocketTask.send

1. Backend receives and processes audio for ASR
   - Evidence:
     - Docs: docs/WS_CONTRACT.md :: `audio` message format
   - Notes: Server-side ASR processing

## Inputs and Outputs

- Inputs: PCM audio frame bytes, source string
- Outputs: JSON message sent over WebSocket
- Side effects (writes, network calls, model loads, UI state changes): Network data transmission, queue depth management

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Send queue full
  - Where detected: sendPCMFrame
  - Current handling (as evidenced): sendQueue.operationCount > maxQueuedSends, drops frame
  - User-visible outcome (if any): Audio frame dropped, debug counters updated
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: if sendQueue.operationCount > maxQueuedSends { return }

- Failure: WebSocket not connected
  - Where detected: Operation execution
  - Current handling (as evidenced): send fails, operation completes without error
  - User-visible outcome (if any): Frame lost
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: task?.send may fail silently

- Failure: Base64 encoding fails
  - Where detected: Data.base64EncodedString()
  - Current handling (as evidenced): None evidenced, assumes success
  - User-visible outcome (if any): Invalid message sent
  - Evidence: Hypothesized

- Failure: JSON serialization fails
  - Where detected: JSONSerialization.data()
  - Current handling (as evidenced): try? , silent failure
  - User-visible outcome (if any): Message not sent
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: guard let jsonData = try? JSONSerialization.data(withJSONObject: payload)

## Data and Storage

- What data is produced/consumed: PCM audio bytes, base64 encoded string
- Where it is stored (DB/files/userData/etc.): In-memory queue during transmission
- Retention / deletion controls (if documented): None, transient

## Observability

- Logs/events emitted: None evidenced for individual frames
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): Queue depth in metrics

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What happens when send fails?
- Documentation gaps to fill: Send failure handling
- Test gaps to add (note only, no implementation): Test queue overflow behavior</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-003.md

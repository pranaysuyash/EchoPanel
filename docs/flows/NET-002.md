# NET-002 WebSocket Authentication Flow

## Summary

- Origin: Code-only
- Status: Implemented
- The client authenticates websocket requests via headers, not URL query token.
- Boundaries crossed: Security / Network
- Primary components (coarse list): BackendConfig, KeychainHelper, WebSocketStreamer, ws_live_listener

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): websocket connect attempt
- Preconditions (permissions, settings flags, availability, model cached, etc.): optional token in keychain; backend may enforce `ECHOPANEL_WS_AUTH_TOKEN`

## Sequence (Happy Path)

1. `BackendConfig.webSocketURL` builds endpoint URL without query auth.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/BackendConfig.swift` :: `webSocketURL` -> `buildURL(path: "/ws/live-listener")`
2. `BackendConfig.webSocketRequest` loads keychain token and sets headers.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/BackendConfig.swift` :: sets `Authorization: Bearer ...` and `x-echopanel-token`
3. `WebSocketStreamer` opens socket with this request object.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `session.webSocketTask(with: webSocketRequest)`
4. Server extracts auth token (query/header/bearer fallback order) and validates against env token.
   - Evidence:
     - Code: `server/api/ws_live_listener.py` :: `_extract_ws_auth_token`, `_is_ws_authorized`
     - Docs: `docs/WS_CONTRACT.md` :: Authentication

## Inputs and Outputs

- Inputs: keychain token (optional), backend env token (optional)
- Outputs: authenticated websocket request or unauthorized close path
- Side effects (writes, network calls, model loads, UI state changes): auth headers included on websocket handshake

## Failure Modes

- Failure: Keychain token missing while server requires auth
  - Where detected: server authorization check
  - Current handling (as evidenced): server emits error status and closes with `1008`
  - User-visible outcome (if any): reconnecting/error state in app
  - Evidence: `server/api/ws_live_listener.py` :: unauthorized websocket handling

- Failure: Keychain token empty string
  - Where detected: client request build
  - Current handling (as evidenced): headers not set due `!token.isEmpty` guard
  - User-visible outcome (if any): same as missing token when auth required
  - Evidence: `macapp/MeetingListenerApp/Sources/BackendConfig.swift` :: `if let token ... !token.isEmpty`

- Failure: Invalid token
  - Where detected: server compare-digest
  - Current handling (as evidenced): unauthorized close (1008)
  - User-visible outcome (if any): reconnect loop until corrected
  - Evidence: `server/api/ws_live_listener.py` :: `hmac.compare_digest(...)`

## Data and Storage

- What data is produced/consumed: backend auth token
- Where it is stored (DB/files/userData/etc.): macOS Keychain via `KeychainHelper`
- Retention / deletion controls (if documented): keychain-managed

## Observability

- Logs/events emitted: server unauthorized status message; client status/error propagation
- Correlation IDs / session IDs (if any): normal websocket correlation IDs still apply
- Metrics/traces (if any): none specific to auth success/failure counters

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: none
- Documentation gaps to fill: align WS contract text to explicitly call out header-first client behavior with query fallback for compatibility
- Test gaps to add (note only, no implementation): integration test proving header auth succeeds when query token omitted

# MOD-014 Memory Management

## Summary

- Origin: Code-only
- Status: Implemented
- Explicit model unloading and memory cleanup on server shutdown, including provider cache eviction and state reset.
- Boundaries crossed: Process, Model
- Primary components (coarse list): ModelPreloader, ASRProviderRegistry

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): FastAPI lifespan shutdown event
- Preconditions (permissions, settings flags, availability, model cached, etc.): Global model manager exists (\_model_manager is not None)

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. lifespan shutdown calls shutdown_model_manager()
   - Evidence:
     - Code: server/main.py :: unloaded = await shutdown_model_manager()

1. shutdown_model_manager() calls manager.unload() on global \_model_manager
   - Evidence:
     - Code: server/services/model_preloader.py :: success = await \_model_manager.unload(timeout=timeout)

1. unload() sets state to UNLOADING, calls provider unload hooks
   - Evidence:
     - Code: server/services/model_preloader.py :: self.\_state = ModelState.UNLOADING; await self.\_run_provider_hook(provider, "unload")

1. ASRProviderRegistry.evict_provider_instance() removes from cache
   - Evidence:
     - Code: server/services/model_preloader.py :: removed = ASRProviderRegistry.evict_provider_instance(provider)

1. Resets runtime state and sets state to UNINITIALIZED
   - Evidence:
     - Code: server/services/model_preloader.py :: self.\_reset_runtime_state_locked(); self.\_state = ModelState.UNINITIALIZED

1. Sets global \_model_manager to None
   - Evidence:
     - Code: server/services/model_preloader.py :: if success: \_model_manager = None

## Inputs and Outputs

- Inputs: Timeout (default 10.0s)
- Outputs: Boolean success indicator
- Side effects (writes, network calls, model loads, UI state changes): GPU/CPU memory freed, provider instances evicted from registry cache

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Unload timeout exceeded
  - Where detected: unload() asyncio.wait_for
  - Current handling (as evidenced): Exception caught, state set to ERROR
  - User-visible outcome (if any): Memory not fully freed, logged error
  - Evidence: server/services/model_preloader.py :: except asyncio.TimeoutError: self.\_state = ModelState.ERROR

- Failure: Provider unload hook fails
  - Where detected: \_run_provider_hook("unload")
  - Current handling (as evidenced): Exception logged, continues with other operations
  - User-visible outcome (if any): Partial cleanup, provider may remain in memory
  - Evidence: server/services/model_preloader.py :: except Exception as e: logger.error(f"Provider unload failed: {e}")

- Failure: Cache eviction fails
  - Where detected: evict_provider_instance()
  - Current handling (as evidenced): Logs removal count, continues
  - User-visible outcome (if any): Provider instances may persist in cache
  - Evidence: server/services/model_preloader.py :: removed = ASRProviderRegistry.evict_provider_instance(provider)

- Failure: Concurrent unload during initialization
  - Where detected: unload() state check
  - Current handling (as evidenced): Waits for existing operations, then proceeds
  - User-visible outcome (if any): Delayed shutdown
  - Evidence: server/services/model_preloader.py :: async with self.\_lock: if provider is None and self.\_state == ModelState.UNINITIALIZED

- Failure: No model manager to unload
  - Where detected: shutdown_model_manager()
  - Current handling (as evidenced): Returns True immediately
  - User-visible outcome (if any): No operation needed
  - Evidence: server/services/model_preloader.py :: if \_model_manager is None: return True

## Data and Storage

- What data is produced/consumed: Model state transitions, provider hook results
- Where it is stored (DB/files/userData/etc.): In-memory ModelPreloader state, global \_model_manager reference
- Retention / deletion controls (if documented): All runtime state reset, global reference cleared

## Observability

- Logs/events emitted: Info logs for unload operations, error logs on failures
- Correlation IDs / session IDs (if any): None evidenced
- Metrics/traces (if any): None evidenced
  Evidence required: server/services/model_preloader.py :: logger.info/logger.error calls

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: Does unload happen on session end or only server shutdown?
- Documentation gaps to fill: Memory usage metrics before/after unload
- Test gaps to add (note only, no implementation): Memory leak detection, unload under load</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/MOD-014.md

# OBS-005 Backend Crash Detection & Restart Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Client monitors backend process termination, detects crashes (non-zero exit codes), and attempts automatic restart with exponential backoff up to 3 attempts.
- Boundaries crossed: Process (subprocess management), OS (signals)
- Primary components (coarse list): BackendManager, Process.terminationHandler

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Backend process terminates unexpectedly
- Preconditions (permissions, settings flags, availability, model cached, etc.): Backend process was running

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Process termination handler fires
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: process.terminationHandler = { proc in ... }
     - Docs: docs/audit/BROADCAST_READINESS_REVIEW_2026-02-11.md :: Backend crash recovery PASS
   - Notes: Async callback on process exit

1. Check if termination was user-requested
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: if self?.stopRequested == true
   - Notes: Distinguishes intentional stops from crashes

1. Detect crash by non-zero exit code
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: let wasError = code != 0
     - Docs: docs/audit/BROADCAST_READINESS_REVIEW_2026-02-11.md :: 3 attempts with exponential backoff
   - Notes: Zero exit codes treated as normal termination

1. Check restart attempt limits
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: if wasError && restartAttempts < maxRestartAttempts
   - Notes: Max 3 attempts to prevent infinite loops

1. Schedule restart with exponential backoff
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: restartDelay \*= 2, Timer.scheduledTimer
   - Notes: Delays: 1s, 2s, 4s (capped at 10s)

1. After delay, attempt server restart
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: startServer(isRecoveryAttempt: true)
   - Notes: Full server startup sequence repeats

## Inputs and Outputs

- Inputs:
  - Process termination status code
  - Current restart attempt count
- Outputs:
  - Server status updates (.starting, .error)
  - Recovery phase updates (.retryScheduled, .failed)
- Side effects (writes, network calls, model loads, UI state changes): Process restart, UI status updates, health check resumption

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Process crashes repeatedly
  - Where detected: restartAttempts >= maxRestartAttempts
  - Current handling (as evidenced): Gives up, sets status to .error
  - User-visible outcome (if any): "Server failed to start after 3 attempts"
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: guard restartAttempts < maxRestartAttempts

- Failure: Restart timer fires after manual stop
  - Where detected: Timer callback executes when stopRequested
  - Current handling (as evidenced): No guard, restart proceeds
  - User-visible outcome (if any): Unexpected restart after stop
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: Timer callback has no stopRequested check

- Failure: Process doesn't terminate gracefully
  - Where detected: terminateGracefully timeout
  - Current handling (as evidenced): Sends SIGINT then SIGKILL
  - User-visible outcome (if any): Force kill logged
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: terminateGracefully with SIGKILL

- Failure: Restart fails with same error
  - Where detected: startServer throws exception
  - Current handling (as evidenced): Caught, status set to .error
  - User-visible outcome (if any): Recovery phase set to .failed
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: catch { serverStatus = .error }

- Failure: Health check timer still running during restart
  - Where detected: Multiple timers active
  - Current handling (as evidenced): Timer invalidated in terminationHandler
  - User-visible outcome (if any): Clean timer state
  - Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: healthCheckTimer?.invalidate()

## Data and Storage

- What data is produced/consumed: Exit codes, restart attempt counts, backoff delays
- Where it is stored (DB/files/userData/etc.): In-memory BackendManager state
- Retention / deletion controls (if documented): Reset on successful start, persisted across attempts

## Observability

- Logs/events emitted: "Server terminated with code X", "Attempting restart #Y in Zs"
- Correlation IDs / session IDs (if any): None (process-level)
- Metrics/traces (if any): None (not metered)
  Evidence: Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: NSLog statements in terminationHandler and attemptRestart

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What specific exit codes indicate different failure types?
- Documentation gaps to fill: Backend crash classification and appropriate responses
- Test gaps to add (note only, no implementation): Test crash recovery with various exit codes


# NET-010 Network Error Recovery

## Summary

- Origin: Code-only
- Status: Implemented
- Client handles various network errors (timeouts, connection failures, send failures) by triggering reconnection with user feedback.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, handleError, reconnect

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): Network error occurs during WebSocket operation
- Preconditions (permissions, settings flags, availability, model cached, etc.): WebSocket connection was established

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Network error detected in send or receive operation
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: sendJSON semaphore timeout, receiveLoop failure case
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Network partition mid-session test
   - Notes: Errors include timeouts, connection drops, TLS failures

1. handleError() called with error details
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleError(error) from sendJSON and receiveLoop
   - Notes: Central error handling entry point

1. Error logged for debugging
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: NSLog("WebSocketStreamer: error %@", error.localizedDescription)
   - Notes: Debug-enabled logging

1. UI status updated to reconnecting with error message
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: onStatus?(.reconnecting, error.localizedDescription)
   - Notes: User feedback during recovery

1. reconnect() initiated with exponential backoff
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnect() called from handleError
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Client auto-reconnects with exponential backoff
   - Notes: Automatic recovery attempt

1. After delay, new connection established
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connect() called after delay
   - Notes: Session state preserved across recovery

## Inputs and Outputs

- Inputs:
  - Network error (timeout, connection failure, etc.)
  - Current session state
- Outputs:
  - Reconnection attempt
  - Status updates (.reconnecting)
- Side effects (writes, network calls, model loads, UI state changes): UI status change, new network connection attempt

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Reconnection fails repeatedly
  - Where detected: Multiple handleError calls
  - Current handling (as evidenced): Infinite retry with backoff
  - User-visible outcome (if any): Persistent "reconnecting" status
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: reconnect() always schedules next attempt

- Failure: Send timeout occurs
  - Where detected: semaphore.wait timeout in sendJSON
  - Current handling (as evidenced): Logs warning, continues with error check
  - User-visible outcome (if any): Logged warning, may trigger reconnection
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: StructuredLogger.shared.warning("WebSocket send timeout")

- Failure: Receive loop fails
  - Where detected: task?.receive completion with failure
  - Current handling (as evidenced): handleError called, reconnection triggered
  - User-visible outcome (if any): Status changes to reconnecting
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: case .failure(let error): self.handleError(error)

- Failure: Error during reconnection setup
  - Where detected: connect() fails internally
  - Current handling (as evidenced): New handleError call from connect attempt
  - User-visible outcome (if any): Continued reconnection attempts
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connect() can fail and call handleError

- Failure: Network completely unavailable
  - Where detected: All connection attempts fail
  - Current handling (as evidenced): Continues retrying indefinitely
  - User-visible outcome (if any): App appears stuck in reconnecting state
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: No maximum retry limit

## Data and Storage

- What data is produced/consumed: Error details, session ID for reconnection
- Where it is stored (DB/files/userData/etc.): In-memory in WebSocketStreamer instance
- Retention / deletion controls (if documented): Cleared on successful disconnect

## Observability

- Logs/events emitted: Error messages logged, structured warnings for timeouts
- Correlation IDs / session IDs (if any): Session ID preserved for reconnection
- Metrics/traces (if any): None (errors not counted as metrics)
  Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: StructuredLogger.shared.warning for timeouts

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: Should there be a maximum retry limit?
- Documentation gaps to fill: Error classification and different recovery strategies
- Test gaps to add (note only, no implementation): Test various network error scenarios and recovery</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-010.md

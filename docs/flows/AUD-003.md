# AUD-003 Dual-Source Redundant Capture with Auto-Failover

## Summary

- Origin: Mixed
- Status: Implemented
- Runs both system audio and microphone capture simultaneously, monitors quality metrics, and automatically fails over from primary (system) to backup (microphone) when quality degrades or silence detected.
- Boundaries crossed: Process (dual capture coordination) / OS (audio devices)
- Primary components: RedundantAudioCaptureManager, AudioCaptureManager, MicrophoneCaptureManager

## Triggers and Preconditions

- Triggers: Session start with audioSource == .both, or broadcast feature activation
- Preconditions: At least one audio source available, both capture managers initialized

## Sequence (Happy Path)

1. Initialize redundant capture with auto-failover enabled
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: func startRedundantCapture(autoFailover: Bool = true) async throws
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Capture start (RedundantAudioCaptureManager.swift:136-162)

2. Start primary capture (system audio)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: try await primaryCapture.startCapture()
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Capture start

3. Start backup capture (microphone) regardless of primary success
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: try backupCapture.startCapture()
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Capture start

4. Set active source to primary and start quality monitoring timer
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: activeSource = .primary; startQualityMonitoring()
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Capture start

5. Set up callbacks for both sources to track frames and quality
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: private func setupCallbacks()
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Callback setup (RedundantAudioCaptureManager.swift:233-282)

6. Quality monitoring timer checks silence and quality every 0.1s
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: private func checkQualityAndFailover()
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Quality monitoring loop (RedundantAudioCaptureManager.swift:284-295, 297-324)

7. If primary silent > 2s or quality poor, and backup recent (< 1s), trigger failover
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: let shouldFailover = timeSincePrimary > failoverSilenceThreshold || primaryQuality == .poor
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Quality monitoring loop

8. Execute failover: switch active source, log event, notify callbacks
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: private func performFailover(from: RedundantAudioSource, to: RedundantAudioSource, reason: FailoverEvent.FailoverReason)
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Failover execution (RedundantAudioCaptureManager.swift:326-347)

9. Emit frames only from active source via onPCMFrame callback
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: if activeSource == .primary || singleSourceMode { onPCMFrame?(frame, source.rawValue) }
     - Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: Callback setup

## Inputs and Outputs

- Inputs: Dual audio streams (system + microphone), quality metrics from both
- Outputs: Single audio stream from active source, failover events, health status
- Side effects: Both capture managers active simultaneously, quality monitoring timer running

## Failure Modes

- Primary capture fails to start:
  - Where detected: primaryCapture.startCapture() throws
  - Current handling: Logged, continues with backup only
  - User-visible outcome: Operates on microphone only
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: catch { NSLog("Primary failed to start: \(error)") }

- Backup capture fails to start:
  - Where detected: backupCapture.startCapture() throws
  - Current handling: Logged, continues with primary only
  - User-visible outcome: Operates on system audio only
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: catch { NSLog("Backup failed to start: \(error)") }

- Both sources fail to start:
  - Where detected: Both start methods throw
  - Current handling: No redundancy active, no frames emitted
  - User-visible outcome: Audio capture completely fails
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: startRedundantCapture throws if both fail

- False positive failover (temporary silence):
  - Where detected: Silence threshold (2s) triggers during speaker pause
  - Current handling: Switches to backup unnecessarily
  - User-visible outcome: Unwanted source switch
  - Evidence: Docs: docs/audit/audio-pipeline-deep-dive-20260211.md :: False positive failover

- Failover when backup unavailable:
  - Where detected: timeSinceBackup > 1.0s during failover check
  - Current handling: Prevents failover, stays on degraded primary
  - User-visible outcome: Remains on poor quality audio
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: if shouldFailover && timeSinceBackup < 1.0

- Rapid failover oscillation:
  - Where detected: Both sources degrade alternately
  - Current handling: No hysteresis, may switch back and forth
  - User-visible outcome: Audio source switching frequently
  - Evidence: Assumed - no hysteresis in logic

- Missing quality updates:
  - Where detected: primaryQuality/backupQuality stuck at .unknown
  - Current handling: Failover logic doesn't trigger
  - User-visible outcome: No automatic failover
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: primaryQuality == .poor

- Thread safety issues:
  - Where detected: Timer updates @Published properties from background thread
  - Current handling: Wrapped in Task { @MainActor in ... }
  - User-visible outcome: Potential UI freezes or crashes
  - Evidence: Code: macapp/MeetingListenerApp/Sources/RedundantAudioCaptureManager.swift :: Task { @MainActor in self?.checkQualityAndFailover() }

## Data and Storage

- Failover events array (accumulates indefinitely)
- Last frame timestamps for both sources
- Quality monitoring timer state

## Observability

- @Published activeSource, isRedundancyActive, quality levels
- Failover events history
- Health status (healthy/degraded/critical)
- Structured logging for failover events
- Debug logging for start/stop/errors

## Open Questions and Follow-up Tasks

- No automatic failback to primary once switched to backup
- Failover events accumulate without cleanup (memory leak)
- No hysteresis to prevent rapid switching
- Silence threshold (2s) may be too sensitive for natural pauses
- Test gaps: Long-running sessions, memory usage, thread safety


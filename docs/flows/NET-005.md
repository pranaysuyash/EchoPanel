# NET-005 WebSocket Disconnection and Cleanup

## Summary

- Origin: Code-only
- Status: Hypothesized
- Client handles WebSocket disconnection, cleans up resources, and may attempt reconnection.
- Boundaries crossed: Network
- Primary components (coarse list): WebSocketStreamer, AppState

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): stopSession() called, or network error, or server closes connection
- Preconditions (permissions, settings flags, availability, model cached, etc.): WebSocket was connected

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. stopSession() calls streamer.disconnect()
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/AppState.swift :: stopSession() calls streamer.disconnect()
   - Notes: Intentional disconnect

1. WebSocketStreamer.disconnect() sends "stop" message
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: sendStop() sends {"type":"stop","session_id":"..."}
   - Notes: Flushes ASR, cancels analysis

1. Cancels pending send operations
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: sendQueue.cancelAllOperations()
   - Notes: P0: Prevent blocking on network stall

1. Cancels WebSocket task with .goingAway
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: task?.cancel(with: .goingAway, reason: nil)
   - Notes: Clean closure

1. Cancels ping timer
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: pingTimer?.invalidate()
   - Notes: Stops health checks

1. Backend processes stop, sends final_summary, closes connection
   - Evidence:
     - Docs: docs/WS_CONTRACT.md :: `stop` message, server closes socket
   - Notes: Runs finalization analysis

## Inputs and Outputs

- Inputs: Disconnect trigger (user action or error)
- Outputs: WebSocket closed, resources cleaned up
- Side effects (writes, network calls, model loads, UI state changes): Stop message sent, connection closed, timers cancelled

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Send stop fails
  - Where detected: sendStop
  - Current handling (as evidenced): try? , silent failure
  - User-visible outcome (if any): Stop not sent, but connection still closes
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: try? task?.send(.string(jsonString))

- Failure: Task cancel fails
  - Where detected: disconnect
  - Current handling (as evidenced): Optional chaining, ignores failure
  - User-visible outcome (if any): Resources not cleaned
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: task?.cancel(with: .goingAway, reason: nil)

- Failure: Backend doesn't close cleanly
  - Where detected: Client side
  - Current handling (as evidenced): None, assumes closure
  - User-visible outcome (if any): Connection may linger
  - Evidence: Hypothesized

## Data and Storage

- What data is produced/consumed: Session ID for stop message
- Where it is stored (DB/files/userData/etc.): In-memory in WebSocketStreamer
- Retention / deletion controls (if documented): None

## Observability

- Logs/events emitted: Structured logging for disconnect
- Correlation IDs / session IDs (if any): session_id
- Metrics/traces (if any): None evidenced

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What triggers automatic reconnection vs clean disconnect?
- Documentation gaps to fill: Reconnection decision logic
- Test gaps to add (note only, no implementation): Test disconnect cleanup</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/NET-005.md

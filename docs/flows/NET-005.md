# NET-005 WebSocket Disconnection and Cleanup

## Summary

- Origin: Code-only
- Status: Implemented
- Session stop path flushes final summary with timeout, then cleans up websocket/capture/session state.
- Boundaries crossed: UI -> Network -> Storage
- Primary components (coarse list): AppState, WebSocketStreamer, SessionStore, SidePanelController

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): user stops listening, side panel window close, startup timeout/error path
- Preconditions (permissions, settings flags, availability, model cached, etc.): session is `.starting` or `.listening`

## Sequence (Happy Path)

1. Session stop is triggered.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/MeetingListenerApp.swift` :: `toggleSession()` stop branch
     - Code: `macapp/MeetingListenerApp/Sources/SidePanelController.swift` :: `windowWillClose` calls `onEndSession`
2. `AppState.stopSession()` transitions to `.finalizing` and stops timers.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `stopSession()`
3. Capture managers stop; websocket stop is requested with final-summary wait.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `audioCapture.stopCapture`, `micCapture.stopCapture`, `streamer.stopAndAwaitFinalSummary(timeout: 10)`
4. `WebSocketStreamer.stopAndAwaitFinalSummary` sends `stop`, waits for `final_summary` or timeout, then closes task and ping.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `stopAndAwaitFinalSummary(timeout:)`
5. App records finalization outcome, saves session data, clears runtime state.
   - Evidence:
     - Code: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `finalizationOutcome`, `sessionStore.endSession(...)`, context resets

## Inputs and Outputs

- Inputs: stop intent, live session IDs, pending websocket state
- Outputs: final summary outcome (`complete` or timeout/error), idle app state
- Side effects (writes, network calls, model loads, UI state changes): stop frame over websocket, persistence to session store, summary notification

## Failure Modes

- Failure: Backend never sends final summary
  - Where detected: stop-and-wait timeout
  - Current handling (as evidenced): outcome set to `.incompleteTimeout`, session still closes cleanly
  - User-visible outcome (if any): finalized with timeout notice semantics
  - Evidence: `macapp/MeetingListenerApp/Sources/AppState.swift` :: `didReceiveFinal` branch

- Failure: Stop invoked while session not active
  - Where detected: guard in `stopSession`
  - Current handling (as evidenced): no-op
  - User-visible outcome (if any): unchanged state
  - Evidence: `macapp/MeetingListenerApp/Sources/AppState.swift` :: guard on session state

- Failure: Explicit disconnect path with pending send operations
  - Where detected: `disconnect()` call path
  - Current handling (as evidenced): send queue cancelled, websocket closed, ping stopped
  - User-visible outcome (if any): immediate teardown
  - Evidence: `macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift` :: `disconnect()`

## Data and Storage

- What data is produced/consumed: finalization state, transcript/actions/decisions/risks/entities payload
- Where it is stored (DB/files/userData/etc.): `SessionStore` + optional session bundle artifacts
- Retention / deletion controls (if documented): managed by session store lifecycle

## Observability

- Logs/events emitted: structured `Session finalizing` and `Session ended` logs
- Correlation IDs / session IDs (if any): session ID attached to shutdown logs and bundle/session writes
- Metrics/traces (if any): no dedicated disconnect latency metric in current client

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: none
- Documentation gaps to fill: none
- Test gaps to add (note only, no implementation): session stop under forced network failure

# EXT-005 Session Stop & Finalization

## Summary

- Origin: Code-only
- Status: Implemented
- Gracefully terminates an active session by stopping audio capture, flushing pending ASR, running final analysis (diarization, summary, entity extraction), and delivering complete session results to client.
- Boundaries crossed: Process (audio capture stop) / Network (WebSocket final summary) / Storage (session bundle update)
- Primary components (coarse list): AppState, WebSocketStreamer, ws_live_listener, analysis services

## Triggers and Preconditions

- Triggers: User clicks stop button, timeout occurs, or error condition
- Preconditions: Active session in .listening or .starting state

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. User initiates stop, app sets sessionState to .finalizing, stops timer
   - Evidence:
     - Code: AppState.swift :: stopSession() :: sessionState = .finalizing; stopTimer()
     - Docs: flow-atlas-20260211.md :: EXT-005 Session Stop & Finalization

1. Stop audio capture (system and/or microphone)
   - Evidence:
     - Code: AppState.swift :: stopSession() :: await audioCapture.stopCapture()
     - Code: AppState.swift :: stopSession() :: micCapture.stopCapture()

1. Send WebSocket stop message to backend
   - Evidence:
     - Code: WebSocketStreamer.swift :: stopAndAwaitFinalSummary() :: self.sendStop()
     - Code: WebSocketStreamer.swift :: sendStop() :: sendJSON(["type": "stop", "session_id": sessionID])

1. Backend receives stop, signals EOF to all audio queues
   - Evidence:
     - Code: ws_live_listener.py :: elif msg_type == "stop"
     - Code: ws_live_listener.py :: for q in state.queues.values(): await q.put(None)

1. Backend waits for ASR tasks to flush final transcriptions
   - Evidence:
     - Code: ws_live_listener.py :: await asyncio.wait_for(asyncio.gather(\*state.asr_tasks), timeout=8)
     - Code: ws_live_listener.py :: logger.warning("ASR flush timed out, transcript may be incomplete")

1. Backend cancels analysis tasks and runs final processing
   - Evidence:
     - Code: ws_live_listener.py :: for t in state.analysis_tasks: t.cancel()
     - Code: ws_live_listener.py :: await asyncio.wait_for(asyncio.gather(\*state.analysis_tasks), timeout=5.0)

1. Backend runs session-end diarization per audio source
   - Evidence:
     - Code: ws_live_listener.py :: diarization_by_source = await \_run_diarization_per_source(state)
     - Code: ws_live_listener.py :: diarization_segments = \_flatten_diarization_segments(diarization_by_source)

1. Backend generates final analysis (summary, cards, entities)
   - Evidence:
     - Code: ws_live_listener.py :: summary_md = await asyncio.to_thread(generate_rolling_summary, transcript_snapshot)
     - Code: ws_live_listener.py :: cards = await asyncio.to_thread(extract_cards, transcript_snapshot)
     - Code: ws_live_listener.py :: entities = await asyncio.to_thread(extract_entities, transcript_snapshot)

1. Backend sends final_summary message with complete session data
   - Evidence:
     - Code: ws_live_listener.py :: await ws_send(state, websocket, {"type": "final_summary", "markdown": summary_md, "json": {...}})
     - Code: ws_live_listener.py :: await websocket.close()

1. Client receives final summary, updates UI, saves session bundle
   - Evidence:
     - Code: AppState.swift :: onFinalSummary :: self?.finalSummaryMarkdown = markdown; self?.finalSummaryJSON = jsonObject
     - Code: AppState.swift :: stopSession() :: sessionStore.endSession(sessionId: id, finalData: exportPayload())

1. Client transitions to idle state, posts summary notification
   - Evidence:
     - Code: AppState.swift :: stopSession() :: self.sessionState = .idle
     - Code: AppState.swift :: stopSession() :: NotificationCenter.default.post(name: .summaryShouldOpen, object: nil)

## Inputs and Outputs

- Inputs: User stop action, sessionID
- Outputs: finalSummaryMarkdown, finalSummaryJSON, finalizationOutcome (.complete/.incompleteTimeout)
- Side effects (writes, network calls, model loads, UI state changes): Audio capture stopped, WebSocket closed, session bundle finalized, summary UI shown, session storage ended

## Failure Modes

List 5â€“10 realistic failures:

- Failure: ASR flush timeout during stop
  - Where detected: asyncio.wait_for on ASR tasks times out
  - Current handling (as evidenced): Warning logged, status sent to client, continues with available transcript
  - User-visible outcome (if any): Warning "ASR processing timed out, some speech may be missing"
  - Evidence: ws_live_listener.py :: except asyncio.TimeoutError: logger.warning("ASR flush timed out")

- Failure: Analysis task cancellation timeout
  - Where detected: asyncio.wait_for on analysis tasks times out
  - Current handling (as evidenced): Warning logged, tasks may be orphaned
  - User-visible outcome (if any): None, but potential resource leak
  - Evidence: ws_live_listener.py :: logger.warning("Analysis task cancellation timed out")

- Failure: Final summary not received within client timeout
  - Where detected: stopAndAwaitFinalSummary timeout (10s)
  - Current handling (as evidenced): finalizationOutcome = .incompleteTimeout
  - User-visible outcome (if any): Incomplete finalization status
  - Evidence: AppState.swift :: if didReceiveFinal { .complete } else { .incompleteTimeout }

- Failure: Diarization processing fails
  - Where detected: \_run_diarization_per_source raises exception
  - Current handling (as evidenced): Exception propagates, may cause final summary failure
  - User-visible outcome (if any): Final summary incomplete or missing
  - Evidence: ws_live_listener.py :: diarization_by_source = await \_run_diarization_per_source(state)

- Failure: WebSocket already disconnected
  - Where detected: ws_send fails during final summary
  - Current handling (as evidenced): Exception caught, session cleanup continues
  - User-visible outcome (if any): No final summary received
  - Evidence: ws_live_listener.py :: await ws_send(state, websocket, {...}) in try block

## Data and Storage

- What data is produced/consumed: Complete transcript with diarization, summary markdown, extracted entities/cards, session metrics
- Where it is stored (DB/files/userData/etc.): Session bundle JSON, in-memory finalSummaryJSON/markdown
- Retention / deletion controls (if documented): Session bundle persists for export, in-memory data cleared on next session

## Observability

- Logs/events emitted: "Session finalizing", "Session ended" with metadata, ASR/analysis timeouts
- Correlation IDs / session IDs (if any): session_id propagated in final summary
- Metrics/traces (if any): ws_disconnects_total counter, session duration metrics
  Evidence: AppState.swift :: StructuredLogger.shared.info("Session finalizing"), ws_live_listener.py :: logger.info final summary

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: What happens to orphaned analysis tasks? How are session bundles cleaned up?
- Documentation gaps to fill: Detailed timeout behavior and resource cleanup
- Test gaps to add (note only, no implementation): Test stop with ASR timeout, test stop with WebSocket disconnect</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/EXT-005.md

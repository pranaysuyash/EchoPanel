# OBS-003 Correlation ID Propagation Flow

## Summary

- Origin: Code-only
- Status: Implemented
- Client generates correlation IDs (session, attempt, connection) and propagates them through WebSocket messages, server echoes them back for observability.
- Boundaries crossed: Network (WebSocket protocol)
- Primary components (coarse list): CorrelationIDs, WebSocketStreamer, ws_live_listener.py

## Triggers and Preconditions

- Triggers (user action, event, schedule, startup, etc.): WebSocket connection establishment
- Preconditions (permissions, settings flags, availability, model cached, etc.): Session started with session_id

## Sequence (Happy Path)

Use numbered sequence. Each step must include evidence.
For each step:

1. <what happens>
   - Evidence:
     - Code: path :: symbol/event/string
     - Docs: path :: heading/snippet
   - Notes: (only if needed)

1. Client generates correlation IDs on connect
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: CorrelationIDs.generate(sessionId, attemptId)
     - Docs: docs/IMPLEMENTATION_SUMMARY_OBSERVABILITY.md :: Correlation ID generation
   - Notes: sessionId from app, attemptId new per connect, connectionId UUID

1. IDs included in start message to server
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: payload["attempt_id"], payload["connection_id"]
     - Docs: docs/WS_CONTRACT.md :: start message includes session_id
   - Notes: Server receives and stores in SessionState

1. Server stores correlation IDs in session state
   - Evidence:
     - Code: server/api/ws_live_listener.py :: state.attempt_id = payload.get("attempt_id"), state.connection_id = ...
   - Notes: Persisted for duration of session

1. Server includes IDs in all response messages
   - Evidence:
     - Code: server/api/ws_live_listener.py :: metrics_payload with session_id, attempt_id, connection_id
     - Docs: docs/WS_CONTRACT.md :: metrics message includes correlation IDs
   - Notes: ASR results, status messages, final summary

1. Client receives and validates correlation IDs
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: handleJSON validates connection_id matches
   - Notes: Ensures messages belong to current connection

1. IDs propagated to logging and metrics
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/StructuredLogger.swift :: context includes correlation IDs
     - Docs: docs/OBSERVABILITY_IMPLEMENTATION.md :: Correlation IDs in logs and metrics
   - Notes: Full observability chain maintained

## Inputs and Outputs

- Inputs:
  - Session ID from app state
  - Attempt ID (generated per connection)
- Outputs:
  - Connection ID (UUID)
  - All WebSocket messages include correlation IDs
- Side effects (writes, network calls, model loads, UI state changes): Correlation IDs in logs, metrics, and all network messages

## Failure Modes

List 5â€“10 realistic failures:

- Failure: Server doesn't receive correlation IDs
  - Where detected: payload.get("attempt_id") returns None
  - Current handling (as evidenced): Server generates connection_id fallback
  - User-visible outcome (if any): Partial correlation, some IDs missing
  - Evidence: Code: server/api/ws_live_listener.py :: state.connection_id = payload.get("connection_id") or str(uuid.uuid4())

- Failure: Client receives wrong connection_id
  - Where detected: object["connection_id"] doesn't match \_correlationIDs?.connectionId
  - Current handling (as evidenced): Message ignored or logged as mismatch
  - User-visible outcome (if any): Stale messages filtered out
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connection_id validation

- Failure: Session ID not provided by client
  - Where detected: sessionId is nil in generate()
  - Current handling (as evidenced): Function requires sessionId parameter
  - User-visible outcome (if any): Connection fails if session not started
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: generate(sessionId:attemptId:)

- Failure: Correlation context not set in logger
  - Where detected: currentContext.isEmpty in log()
  - Current handling (as evidenced): Context omitted from log entry
  - User-visible outcome (if any): Logs lack correlation IDs
  - Evidence: Code: macapp/MeetingListenerApp/Sources/StructuredLogger.swift :: if !currentContext.isEmpty

- Failure: Server generates different connection_id
  - Where detected: Client and server have different connection_ids
  - Current handling (as evidenced): Client validates and may reject messages
  - User-visible outcome (if any): Message filtering based on connection validity
  - Evidence: Code: macapp/MeetingListenerApp/Sources/WebSocketStreamer.swift :: connection_id matching

## Data and Storage

- What data is produced/consumed: session_id, attempt_id, connection_id
- Where it is stored (DB/files/userData/etc.): Client: WebSocketStreamer instance, Server: SessionState
- Retention / deletion controls (if documented): Cleared on disconnect, persisted per session

## Observability

- Logs/events emitted: Correlation IDs in structured logs
- Correlation IDs / session IDs (if any): Self-referential (the IDs themselves are the correlation mechanism)
- Metrics/traces (if any): IDs included in metrics payloads
  Evidence: Code: server/api/ws_live_listener.py :: metrics_payload includes all three IDs

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: How are correlation IDs used for distributed tracing?
- Documentation gaps to fill: Correlation ID lifecycle across reconnections
- Test gaps to add (note only, no implementation): Test correlation ID propagation end-to-end


# SEC-014 Authorization & Access Control

## Summary
- Origin: Mixed
- Status: Partial Implemented (token-based, no RBAC)
- Token-based authentication for WebSocket and HTTP API access with secure storage in macOS Keychain. No role-based access control implemented.
- Boundaries crossed: UI / OS (Keychain) / Network
- Primary components (coarse list): KeychainHelper (Swift), BackendConfig (Swift), ws_live_listener.py (Python), documents.py (Python)

## Triggers and Preconditions
- Triggers: App startup, WebSocket connection attempt, HTTP API request
- Preconditions: Backend server running with ECHOPANEL_WS_AUTH_TOKEN environment variable set (optional), user has configured backend token in app settings

## Sequence (Happy Path)
1. User enters backend authentication token in app settings UI
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/MeetingListenerApp.swift :: onChange(of: backendToken) { KeychainHelper.saveBackendToken(token) }
     - Docs: docs/flow-atlas-20260211.md :: SEC-014 Authorization & Access Control

2. Token stored securely in macOS Keychain with kSecAttrAccessibleAfterFirstUnlock
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/KeychainHelper.swift :: saveBackendToken() :: kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock
     - Docs: docs/audit/security-privacy-boundaries-20260211.md :: Access control: kSecAttrAccessibleAfterFirstUnlock

3. Client loads token from Keychain on WebSocket connection
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: webSocketRequest :: KeychainHelper.loadBackendToken()
     - Docs: docs/WS_CONTRACT.md :: EchoPanel client sends Authorization + x-echopanel-token headers

4. Client attaches token to WebSocket handshake headers (Authorization: Bearer <token>, x-echopanel-token: <token>)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization"); request.setValue(token, forHTTPHeaderField: "x-echopanel-token")
     - Docs: docs/WS_CONTRACT.md :: 3) Authorization: Bearer ... header

5. Server extracts token from WebSocket headers (priority: query param -> x-echopanel-token header -> Authorization Bearer)
   - Evidence:
     - Code: server/api/ws_live_listener.py :: _extract_ws_auth_token() :: websocket.query_params.get("token"); websocket.headers.get("x-echopanel-token"); auth_header[7:].strip()
     - Docs: docs/flow-atlas-20260211.md :: SEC-005 WebSocket Authentication

6. Server validates token against ECHOPANEL_WS_AUTH_TOKEN environment variable using constant-time comparison
   - Evidence:
     - Code: server/api/ws_live_listener.py :: _is_ws_authorized() :: hmac.compare_digest(provided_token, required_token)
     - Docs: docs/audit/STREAMING_ASR_AUDIT_2026-02.md :: Authentication & Authorization

7. If token valid, WebSocket connection proceeds; if invalid or missing, connection rejected with 1008 close code
   - Evidence:
     - Code: server/api/ws_live_listener.py :: if not _is_ws_authorized(websocket): await websocket.send_text(...); await websocket.close(code=1008)
     - Docs: docs/audit/BROADCAST_READINESS_REVIEW_2026-02-11.md :: token auth optional

## Inputs and Outputs
- Inputs: User-provided backend token string, ECHOPANEL_WS_AUTH_TOKEN environment variable
- Outputs: WebSocket connection success/failure, HTTP API access granted/denied
- Side effects (writes, network calls, model loads, UI state changes): Token persisted to macOS Keychain, WebSocket headers sent on network

## Failure Modes
- Failure: Token storage to Keychain fails
  - Where detected: KeychainHelper.saveBackendToken() returns false
  - Current handling (as evidenced): UI shows error message "Couldn't save backend token to Keychain"
  - User-visible outcome (if any): Error text in settings UI
  - Evidence: macapp/MeetingListenerApp/Sources/MeetingListenerApp.swift :: backendTokenSaveError = "Couldn't save backend token to Keychain..."

- Failure: WebSocket token validation fails (wrong token or missing)
  - Where detected: _is_ws_authorized() returns false
  - Current handling (as evidenced): Connection rejected with error message sent
  - User-visible outcome (if any): WebSocket connection fails, app shows connection error
  - Evidence: server/api/ws_live_listener.py :: await websocket.send_text(json.dumps({"type": "status", "state": "error", "message": "Unauthorized websocket connection"}))

- Failure: HTTP API token validation fails
  - Where detected: _require_http_auth() raises HTTPException
  - Current handling (as evidenced): 401 Unauthorized response returned
  - User-visible outcome (if any): API calls fail with 401 status
  - Evidence: server/api/documents.py :: raise HTTPException(status_code=401, detail="Unauthorized")

- Failure: Keychain access denied (e.g., after device unlock)
  - Where detected: KeychainHelper.loadBackendToken() returns nil
  - Current handling (as evidenced): Token not sent in headers, auth bypassed if server allows
  - User-visible outcome (if any): Silent failure, connection may work if server auth optional
  - Evidence: macapp/MeetingListenerApp/Sources/BackendConfig.swift :: if let token = KeychainHelper.loadBackendToken(), !token.isEmpty

- Failure: Server ECHOPANEL_WS_AUTH_TOKEN not set
  - Where detected: _is_ws_authorized() checks if required_token is empty
  - Current handling (as evidenced): Auth bypassed, connection allowed
  - User-visible outcome (if any): None, connection succeeds
  - Evidence: server/api/ws_live_listener.py :: if not required_token: return True

## Data and Storage
- What data is produced/consumed: Backend authentication token (string)
- Where it is stored (DB/files/userData/etc.): macOS Keychain (GenericPassword class, service: com.echopanel.MeetingListenerApp, account: backendToken)
- Retention / deletion controls (if documented): Token persists until explicitly changed or deleted, migration from UserDefaults on first access

## Observability
- Logs/events emitted: None specific to auth flow
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): None
Evidence: No logging found in auth-related code paths

## Open Questions and Follow-up Tasks
- Questions that cannot be answered from current evidence: How is the backend token initially obtained/generated? Is there a UI flow for token generation?
- Documentation gaps to fill: Token generation/setup process, RBAC design considerations
- Test gaps to add (note only, no implementation): Keychain access failure scenarios, token rotation, concurrent auth attempts</content>
<parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/SEC-014.md
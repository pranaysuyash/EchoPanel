# EXT-013 Backend Auto-Restart/Recovery

## Summary

- Origin: Mixed
- Status: Implemented
- 1â€“2 sentence description: Automatically restarts the Python backend server after unexpected crashes using exponential backoff with a maximum of 3 attempts, preventing permanent service loss.
- Boundaries crossed: Process / OS
- Primary components (coarse list): BackendManager (Swift), Process termination handler

## Triggers and Preconditions

- Triggers: Backend server process terminates unexpectedly (non-zero exit code)
- Preconditions: Server was running, termination was not user-initiated (stopRequested = false), restart attempts < maxRestartAttempts (3)

## Sequence (Happy Path)

1. Backend server process exits with non-zero code
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: process.terminationHandler = { [weak self] proc in ... let code = Int(proc.terminationStatus) ... if self?.stopRequested == true { ... } else { ... if wasError && (self?.restartAttempts ?? 0) < (self?.maxRestartAttempts ?? 3) { self?.attemptRestart() } }
     - Docs: docs/flow-atlas-v2-20260212.md :: "Recovering backend (attempt X/3)..."
   - Notes: Termination handler runs on main thread via DispatchQueue.main.async

2. attemptRestart() increments attempt counter and schedules delayed restart
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: private func attemptRestart() { ... restartAttempts += 1 ... restartTimer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] \_ in self?.startServer(isRecoveryAttempt: true) } }
     - Docs: docs/IMPLEMENTATION_TICKETS_ROADMAP.md :: Recovery when conditions improve
   - Notes: Uses exponential backoff (1s, 2s, 4s, capped at 10s max)

3. Timer fires, calls startServer(isRecoveryAttempt: true)
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: restartTimer = Timer.scheduledTimer(withTimeInterval: delay, repeats: false) { [weak self] \_ in self?.startServer(isRecoveryAttempt: true) }
   - Notes: isRecoveryAttempt prevents resetting attempt counters

4. Server starts successfully, health checks pass
   - Evidence:
     - Code: macapp/MeetingListenerApp/Sources/BackendManager.swift :: startHealthCheck() ... checkHealth() ... if statusCode == 200 && status == "ok" { ... isServerReady = true ... serverStatus = .running }
   - Notes: Health check runs every 1 second until server is ready

## Inputs and Outputs

- Inputs: None (triggered by process termination)
- Outputs: None
- Side effects (writes, network calls, model loads, UI state changes): Server process restart, UI status updates ("Recovering backend (attempt X/3)..."), log entries

## Failure Modes

- Failure: Server fails to start after max attempts (3)
  - Where detected: attemptRestart() when restartAttempts >= maxRestartAttempts
  - Current handling (as evidenced): Sets serverStatus = .error, healthDetail = "Server failed to start after X attempts", recoveryPhase = .failed
  - User-visible outcome (if any): UI shows "Backend unavailable." or error detail
  - Evidence: macapp/MeetingListenerApp/Sources/BackendManager.swift :: guard restartAttempts < maxRestartAttempts else { ... serverStatus = .error ... recoveryPhase = .failed }

- Failure: Port already in use during restart attempt
  - Where detected: probeExistingBackend() returns .portInUse
  - Current handling (as evidenced): Sets serverStatus = .error, healthDetail = "Port X is already in use..."
  - User-visible outcome (if any): UI shows port conflict error
  - Evidence: macapp/MeetingListenerApp/Sources/BackendManager.swift :: case .portInUse: ... serverStatus = .error ... healthDetail = "Port \(serverPort) is already in use..."

- Failure: Python executable not found during restart
  - Where detected: findPythonPath() returns nil
  - Current handling (as evidenced): Sets serverStatus = .error, recoveryPhase = .failed
  - User-visible outcome (if any): UI shows error state
  - Evidence: macapp/MeetingListenerApp/Sources/BackendManager.swift :: guard let pythonPath = findPythonPath(serverDir: serverPath) else { ... serverStatus = .error ... recoveryPhase = .failed }

- Failure: Server directory not found during restart
  - Where detected: findServerPath() returns nil
  - Current handling (as evidenced): Sets serverStatus = .error, recoveryPhase = .failed
  - User-visible outcome (if any): UI shows error state
  - Evidence: macapp/MeetingListenerApp/Sources/BackendManager.swift :: guard let serverPath = findServerPath() else { ... serverStatus = .error ... recoveryPhase = .failed }

- Failure: Process launch fails during restart
  - Where detected: process.run() throws error
  - Current handling (as evidenced): Sets serverStatus = .error, recoveryPhase = .failed
  - User-visible outcome (if any): UI shows error state
  - Evidence: macapp/MeetingListenerApp/Sources/BackendManager.swift :: do { try process.run() ... } catch { ... serverStatus = .error ... recoveryPhase = .failed }

## Data and Storage

- What data is produced/consumed: None (process lifecycle management only)
- Where it is stored (DB/files/userData/etc.): None
- Retention / deletion controls (if documented): N/A

## Observability

- Logs/events emitted: "BackendManager: Server terminated with code X", "BackendManager: Attempting restart #X in Ys", "BackendManager: Starting server"
- Correlation IDs / session IDs (if any): None
- Metrics/traces (if any): None
  Evidence required: macapp/MeetingListenerApp/Sources/BackendManager.swift :: NSLog statements in terminationHandler and attemptRestart

## Open Questions and Follow-up Tasks

- Questions that cannot be answered from current evidence: None
- Documentation gaps to fill: None
- Test gaps to add (note only, no implementation): Integration test for crash recovery under load, test exponential backoff timing</content>
  <parameter name="filePath">/Users/pranay/Projects/EchoPanel/docs/flows/EXT-013.md
